<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>发布代码到CocoaPods</title>
      <url>/ios/2018/02/26/%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E5%88%B0CocoaPods/</url>
      <content type="text">为自己的项目创建 podspec 文件。，首先通过如下命令初始化一个podspec文件：

pod spec create your_pod_spec_name



your_pod_spec_name即KBCycleScrollView

该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。

具体配置信息如下

Pod::Spec.new do |s|

  s.name         = &quot;KBCycleScrollView&quot;
  s.version      = &quot;0.0.1&quot;
  s.summary      = &quot;A short description of KBCycleScrollView.&quot;

  s.homepage     = &quot;https://github.com/kangbingbing/KBCycleScrollView&quot;

  s.license      = &quot;MIT&quot;

  s.author             = { &quot;kang&quot; =&amp;gt; &quot;493043919@qq.com&quot; }
  s.platform     = :ios
  s.platform     = :ios, &quot;7.0&quot;

  s.source       = { :git =&amp;gt; &quot;https://github.com/kangbingbing/KBCycleScrollView.git&quot;, :tag =&amp;gt; &quot;0.0.1&quot; }

  s.source_files  = &quot;KBCycleScrollView&quot;, &quot;KBCycleScrollView/KBCycleScrollView/**/*.{h,m}&quot;

  s.framework  = &quot;UIKit&quot;

  s.requires_arc = true
  
  s.dependency 'SDWebImage', '&amp;gt;= 4.0.0'

end



注意s.source_files文件路径配置，文件夹结构如下:



验证spce文件是否可用

pod spec lint KBCycleScrollView.podspec --use-libraries --allow-warnings





注意项目由于依赖第三方库, 务必加上 –use-libraries 否则会验证失败。

注册 CocoaPods 账号, 邮箱会收到一个验证链接

pod trunk register 493043919@qq.com 'kangbing'





点击邮箱链接完成验证



发布

pod trunk push




</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>路由器灯光控制方案</title>
      <url>/other/2018/01/11/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%81%AF%E5%85%89%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
      <content type="text">路由器灯光控制方案

MT7620系列指示灯控制方案，启动时红灯，启动后黄灯，有Internet连接蓝灯，无Internet连接黄灯。

在路由器启动之后执行 里面添加

mtk_gpio -d 8 1    #关闭红灯
mtk_gpio -d 11 1   #开启黄灯
logger -t &quot;【路由器启动后】&quot; &quot;开启黄灯&quot;



在路由器关闭前执行 里面添加

mtk_gpio -d 10 0   #关闭蓝灯
mtk_gpio -d 11 0   #关闭黄灯
mtk_gpio -d 8 0    #开启红灯
logger -t &quot;【路由器关闭前】&quot; &quot;开启红灯&quot;



自定义设置里面-网络检测下面将网络检测模式调为-持续检测，在网络运行状态改变时运行 脚本里面添加以下代码

logger -t &quot;【Internet检测】&quot; &quot;Internet检测开始&quot;
#超时时间  
timeout=5  
#目标网站  
target=www.baidu.com  
#获取响应状态码  
ret_code=`curl -I -s --connect-timeout $timeout $target -w %{http_code} | tail -n1`  
    if [ &quot;x$ret_code&quot; = &quot;x200&quot; ]; then  
       #网络畅通
       mtk_gpio -d 8 1    #关闭红灯
       mtk_gpio -d 11 0   #关闭黄灯
       mtk_gpio -d 10 1   #开启蓝灯
       logger -t &quot;【Internet检测】&quot; &quot;互联网在线，已切换蓝灯&quot;
    else  
       #网络不畅通
       mtk_gpio -d 8 1    #关闭红灯
       mtk_gpio -d 10 0   #关闭蓝灯
       mtk_gpio -d 11 1   #开启黄灯
       logger -t &quot;【Internet检测】&quot; &quot;互联网已断开，已切换黄灯&quot;
    fi



</content>
      <categories>
        
          <category> Other </category>
        
      </categories>
      <tags>
        
          <tag> Other </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>利用python pdf转图片</title>
      <url>/python/2017/10/12/%E5%88%A9%E7%94%A8python-pdf%E8%BD%AC%E5%9B%BE%E7%89%87/</url>
      <content type="text">环境配置

安装ImageMagick

brew install imagemagick



这里有个坑，brew安装都是7.x版本，使用wand时会出错，需要你安装6.x版本。
解决办法：

1.安装6.x版本

brew install imagemagick@6



2.取消链接7.x版本

brew unlink imagemagick



Unlinking /usr/local/Cellar/imagemagick/7.0.7-4… 71 symlinks removed

3.强制链接6.x版本

 	brew link imagemagick@6 –force

Linking /usr/local/Cellar/imagemagick@6/6.9.9-15… 75 symlinks created

4.export环境变量
 echo ‘export PATH=”/usr/local/opt/imagemagick@6/bin:$PATH”’ » ~/.bash_profile

ok，以上解决imagemagick版本问题。

代码如下:

#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8

from wand.image import Image
from PyPDF2 import PdfFileReader
import logging
import os
import warnings
import multiprocessing
import re


def logs():
    # 禁用警告
    warnings.filterwarnings('ignore')
    # 设置logging
    if not os.path.exists('logs'): os.mkdir('logs')
    log_filename = 'logs/pdf2img.log'
    logging.basicConfig(filename=log_filename, filemode='a', level=logging.DEBUG,
                        format='%(asctime)s %(filename)s [%(levelname)s] %(message)s',
                        datefmt='[%Y-%m-%d %H:%M:%S]',
                        )


def process(single_page):
    pattern = re.compile('\[|\]')
    # 页码
    page_num = pattern.split(single_page)[1]
    with Image(filename=single_page, resolution=200) as converted:
        converted.compression_quality = 45
        newfilename = file_text + page_num + '.jpg'
        converted.save(filename=newfilename)
        logging.info(multiprocessing.current_process().name + '' + newfilename)
    if not os.path.isfile(newfilename): logging.warning('page of file is not found:[%s]' % (newfilename))


def get_pages(filename):
    return PdfFileReader(file(filename, 'rb')).getNumPages()


if __name__ == '__main__':
    logs()
    try:
        get_source = '设计规范模板.pdf'
        file_text = os.path.splitext(get_source)[0]
        pages = get_pages(get_source)
        process_num = multiprocessing.cpu_count()
        pool = multiprocessing.Pool(processes=process_num)
        page_list = [get_source + &quot;[&quot; + str(i) + &quot;]&quot; for i in range(pages)]
        logging.info('=========&amp;gt;&amp;gt;&amp;gt;&amp;gt; Start [Process num: %s]' % (process_num))
        pool.map(process, page_list)
        pool.close()
        pool.join()
        print 'Page Size:%s' % (pages)
        logging.info('&amp;lt;&amp;lt;&amp;lt;========= End')
    except Exception, e:
        logging.error(e)
        print 'Page Size:0'



运行

python pdf2img.py




</content>
      <categories>
        
          <category> Python </category>
        
      </categories>
      <tags>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python爬虫：爬取图片进阶篇</title>
      <url>/python/2017/09/26/python%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      <content type="text">今天目标站妹子图，博眼球真是费了心。

三步走


  获取这个网址的html，解析拿到图集的网址
  访问图集的地址，找到图片的下载地址
  下载图片




获取这个网址的html，解析拿到图集的网址

每页一共15套图的地址，可根据页码进行访问

# html = urllib2.urlopen('http://www.mmjpg.com').read()
html = urllib2.urlopen('http://www.mmjpg.com/home/%s' % page).read()
# 解析html
soup = BeautifulSoup(html)
spanResult = soup.findAll('span',attrs={&quot;class&quot;:&quot;title&quot;})

for a in spanResult:
    name = a.find('a').string
    href = a.find('a').get('href')





访问图集的地址，找到图片的下载地址

获取每一套图总数量

linkreq = urllib2.Request(href)
linkresponse = urllib2.urlopen(linkreq)
htmlres = linkresponse.read()
soups = BeautifulSoup(htmlres)
imageResult = soups.findAll('div',attrs={&quot;id&quot;:&quot;content&quot;})
# print imageResult
totalDiv = soups.find('div',attrs={'class':&quot;page&quot;})
#  每套图的总数量
aCount = totalDiv.findAll('a')[-2].string
print aCount

for div in imageResult:
    # 得到所有的img标签
    image = div.find('img')
    # print image
    link = image.get('src')
    # print link



下载图片

根据获取的图片总数量下载图片

 # 拿到链接截取拼接
 for x in range(0,int(aCount)):
     x += 1
     urlresult = '%s%s%s' % (link[:-5], x, '.jpg')
     filePath = '/Users/kangbing/Desktop/image/%s%s.jpg' % (name,x)
     urllib.urlretrieve(urlresult,filePath)
     # print urlresult
     # print filePath.encode('utf-8')	






  
    downLoadAllImage() 传入页码下载某一页
  
  
    totalPage(2) 	传入页码下载总页数
  


最终代码：

#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8

import urllib2
import urllib
import os
from BeautifulSoup import BeautifulSoup

# 根据传入页码下载，默认下载首页，每页15
def downLoadAllImage(page=1):
    # html = urllib2.urlopen('http://www.mmjpg.com').read()
    html = urllib2.urlopen('http://www.mmjpg.com/home/%s' % page).read()
    # 解析html
    soup = BeautifulSoup(html)
    spanResult = soup.findAll('span',attrs={&quot;class&quot;:&quot;title&quot;})

    for a in spanResult:
        name = a.find('a').string
        href = a.find('a').get('href')
        linkreq = urllib2.Request(href)
        linkresponse = urllib2.urlopen(linkreq)
        htmlres = linkresponse.read()
        soups = BeautifulSoup(htmlres)
        imageResult = soups.findAll('div',attrs={&quot;id&quot;:&quot;content&quot;})
        # print imageResult
        totalDiv = soups.find('div',attrs={'class':&quot;page&quot;})
        #  每套图的总数量
        aCount = totalDiv.findAll('a')[-2].string
        print aCount
        # print totalDiv

        for div in imageResult:
            # 得到所有的img标签
            image = div.find('img')
            # print image
            link = image.get('src')
            # print link
            # 拿到链接截取拼接
            for x in range(0,int(aCount)):
                x += 1
                urlresult = '%s%s%s' % (link[:-5], x, '.jpg')
                filePath = '/Users/kangbing/Desktop/image/%s%s.jpg' % (name,x)
                urllib.urlretrieve(urlresult,filePath)
                # print urlresult
                # print filePath.encode('utf-8')


# 根据传入页码下载前n页，传5就是前5页 共n*15，默认1页即首页
def totalPage(page=1):

    for x in xrange(0,page):
        x += 1
        downLoadAllImage(x)



if __name__ == '__main__':

    downLoadAllImage(1)
    # totalPage(2)





温馨提示:

  身体不好的学习技术就好了，图片还是删了吧。。。


代码已上传至 github

</content>
      <categories>
        
          <category> Python </category>
        
      </categories>
      <tags>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python爬虫：爬取小说芈月传</title>
      <url>/python/2017/09/25/python%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E5%B0%8F%E8%AF%B4%E8%8A%88%E6%9C%88%E4%BC%A0/</url>
      <content type="text">前一篇已经写了如何用python获得图片，这篇看获得文本信息。

分析网页结构

整个流程基本一样，先打开网站找到想要的文本信息，小说地址 http://www.136book.com/mieyuechuanheji/， 打开右键查看源码如图：



可以看到章节列表ol标签里class=clearfix

获取所有的class为clearfix的ol标签

url = 'http://www.136book.com/mieyuechuanheji/'    req = urllib2.Request(url)    response = urllib2.urlopen(req)    html = response.read()    soup = BeautifulSoup(html)    divResult = soup.findAll('ol',attrs={&quot;class&quot;:&quot;clearfix&quot;})



遍历ol标签拿到a标签的文本及连接

for div in divResult:
    # 拿到所有的a标签
    aarray = div.findAll('a')
    for a in aarray:
        print a.string
        link = a.get('href')



link就是每一章节的链接，点击某个章节，查看源码如图：



小说内容在 id=content 的div，获取文本内容

linkreq = urllib2.Request(link)
linkresponse = urllib2.urlopen(linkreq)
   	htmlres = linkresponse.read()
   	soups = BeautifulSoup(htmlres)
   	textResult = soups.findAll('div',attrs={&quot;id&quot;:&quot;content&quot;})



遍历内容中所有的p标签，写入带txt文件中

for p in textResult:
    parray = p.findAll('p')
    for string in parray:
        f.write(string.string)
        f.write('\n\n')



正在下载：



下载完成：



全部源码如下

#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8
import urllib2
import urllib
from BeautifulSoup import BeautifulSoup
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
 
if __name__ == '__main__':
    url = 'http://www.136book.com/mieyuechuanheji/'
    req = urllib2.Request(url)
    response = urllib2.urlopen(req)
    html = response.read()
    soup = BeautifulSoup(html)
    divResult = soup.findAll('ol',attrs={&quot;class&quot;:&quot;clearfix&quot;})

    print divResult
    for div in divResult:
        # 得到所有的a标签
        aarray = div.findAll('a')
        f = open('/Users/kangbing/Desktop/python/miyuezhuan.txt','w')
        for a in aarray:
            print a.string
            link = a.get('href')
            linkreq = urllib2.Request(link)
            linkresponse = urllib2.urlopen(linkreq)
            htmlres = linkresponse.read()
            soups = BeautifulSoup(htmlres)
            textResult = soups.findAll('div',attrs={&quot;id&quot;:&quot;content&quot;})
            
            f.write(a.string)
            for p in textResult:
                parray = p.findAll('p')
                for string in parray:
                    f.write(string.string)
                    f.write('\n\n')
        f.close()



整个爬取小说过程及套路基本都这样，当然获取每个节点的方法有优化的地方，同时可以参考BeautifulSoup这个库的文档，尝试用别的更简单的方法实现，文档地址：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html
</content>
      <categories>
        
          <category> Python </category>
        
      </categories>
      <tags>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python初体验：获取下载网页上的图片</title>
      <url>/python/2017/09/23/python%E5%88%9D%E4%BD%93%E9%AA%8C-%E8%8E%B7%E5%8F%96%E4%B8%8B%E8%BD%BD%E7%BD%91%E9%A1%B5%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      <content type="text">利用python爬网站上的图片并下载



打开链接https://www.douban.com/photos/album/1652407753/, 如图是一个相册.



如何下载网页上的图片, 如下图:


python 有很多强大的库, beautifulsoup 这个库解析html非常好用

安装BeautifulSoup

sudo pip install BeautifulSoup



如果出现-bash: pip: command not found，先安装 pip

sudo easy_install pip



网页右键查看源码, CMD+F 查找这个图片所在位置


图片链接在div标签下的img标签里，现在需要做的就是把这种类型的div从所有html中分离出来，但是这个div标签有个属性叫做class，属性的值是class=”photo_wrap”。拿到这个div集合，遍历里面的img标签，得到图片地址，再下载到本地。代码如下：

#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8

import urllib2
import urllib
import os
from BeautifulSoup import BeautifulSoup

def downLoadAllImage():
    html = urllib2.urlopen('https://www.douban.com/photos/album/1652407753/').read()
    # 解析html
    soup = BeautifulSoup(html)
    # 从html里找到所有class 为 photo_wrap 的div
    divResult = soup.findAll('div',attrs={&quot;class&quot;:&quot;photo_wrap&quot;})
    x = 0
    for div in divResult:
        # 得到所有的img标签
        imageArray = div.findAll('img')
        for image in imageArray:
            # 拿到img标签的链接
            link = image.get('src')
            # 拼接路径
            filePath = '/Users/kangbing/Desktop/images/%s.jpg' % x
            x += 1
            print filePath
            # 下载并保存到本地
            urllib.urlretrieve(link,filePath)

if __name__ == '__main__':
    downLoadAllImage()



注意代码格式，python代码结尾不用分号，但是对格式要求非常严格，少一个或者多一个Tap就报错。
终端运行 image.py 文件就开始自动下载图片了。（记得新建images存放图片的文件夹）

</content>
      <categories>
        
          <category> Python </category>
        
      </categories>
      <tags>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>iOS反动态调试</title>
      <url>/ios/2017/09/18/iOS%E5%8F%8D%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/</url>
      <content type="text">逆向开发者会使用LLDB对应用进行调试，LLDB是Xcode中的动态调试工具。

反调试也就是屏蔽调试器挂载

使用 ptrace 函数

typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);

#if !defined(PT_DENY_ATTACH)

#define PT_DENY_ATTACH 31

#endif  // !defined(PT_DENY_ATTACH)


void disable_gdb() {

void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);

ptrace_ptr_t ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);

ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);

dlclose(handle);
}



disable_gdb 去阻止调试器，但是通过这种方法很容易被修改。运行时断点ptrace直接 return，就破解了。

用汇编去调用ptrace，这样就无法通过函数替换来实现反调试了，必须通过修改二进制文件中的汇编代码才能反调试。攻击者可以使用nop来移除掉命令svc #0x80，但是这种破解难度就比前面的要高很多。

static __attribute__((always_inline)) void debug()
{
#ifdef __arm64__
    __asm__(&quot;mov X0, #31 \t\n&quot;
            &quot;mov X1, #0 \t\n&quot;
            &quot;mov X2, #0 \t\n&quot;
            &quot;mov X3, #0 \t\n&quot;
            &quot;mov w16, #26 \t\n&quot; // ip1 指针。
            &quot;svc #0x80&quot;
            );
#elif __arm__
    __asm__(
            &quot;mov r0, #31 \t\n&quot;
            &quot;mov r1, #0 \t\n&quot;
            &quot;mov r2, #0 \t\n&quot;
            &quot;mov r3, #0 \t\n&quot;
            &quot;mov ip, #26 \t\n&quot;
            &quot;svc #0x80&quot;
            );
#endif
    return;
}



使用的时候直接调用debug()，同时可以在多出调用debug()，增加破解难度。

sysctl 检测到调试器后使用 exit(-1) 强制退出程序，这样就无法继续

static int is_debugged(){
	int name[4] = {CTL_KERN,KERN_PROC,KERN_PROC_PID,getpid()};
    struct kinfo_proc Kproc;
    size_t kproc_size = sizeof(Kproc);
    
    memset((void*)&amp;amp;Kproc, 0, kproc_size);
    
    if (sysctl(name, 4, &amp;amp;Kproc, &amp;amp;kproc_size, NULL, 0) == -1) {
        perror(&quot;sysctl error \n &quot;);
        exit(-1);
    }
    
    return (Kproc.kp_proc.p_flag &amp;amp; P_TRACED) ? 1 : 0;
}
	
	
if (is_debugged() == YES) {
    NSLog(@&quot;is_debugged &quot;);
    exit(-1);
}else{
    NSLog(@&quot;not is_debugged&quot;);
}



以上两种方法基本可以防止一般hacker动态调试app，具体深入研究可以参考http://bbs.iosre.com

参考资料：http://www.jianshu.com/p/122f9e4db055
		http://bbs.iosre.com/t/7-2-0-ios/770/14
</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>动态生成appIcon(加水印)</title>
      <url>/ios/2017/09/16/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90AppIcon(%E5%8A%A0%E6%B0%B4%E5%8D%B0)/</url>
      <content type="text">首先,  安装ImageMagick，ImageMagick是一个非常强大的图形处理库，专门通过终端进行。你可以非常简单地通过Homebrew来安装ImageMagick。

1  更新brew

brew update



2	安装ImageMagick

brew install ImageMagick



3	接下来，安装Ghostscript，因为你将使用的ImageMagick会依赖它。它提供了支持ImageMagick的字体。

brew install ghostscript



4 尝试更改一张图片, 先切换路径到图片所在文件夹



执行

convert icon.png -fill black -font Times-Bold -pointsize 18 -gravity south -annotate 0 &quot;kangbing&quot; icon1.png





icon.png 是原文件名;

fill black 设置文本为白色;

font Times-Bold 利用ImageMagick使用的字体;

pointsize 18 设置字体的大小18;

gravity south 文本与图片的底部对齐

annotate 0 “kangbing” 利用ImageMagick使带有“kangbing”文本的图片旋转的度数为0度；

icon1.png 	最后输出的文件名。

5	现在已经成功生成一张图片, 下面就需要在Xcode里集成命令, 生成图片, 在进行打包.
创建一个工程icon, 并把icon放进工程.



编译之前先运行脚本, 创建脚本



创建成功, 如下图



打印编译运行项目后文件所在路径,  右键查看包内容, 可看到ipa资源
echo “${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}”

打印项目文件所在的文件夹路径
echo “${SRCROOT}”



查看编译log



第一个路径是项目编译运行后所在的文件路径, 包资源里有生成的icon图, 也就是运行在手机里的icon



第二个路径是我们本地项目所在路径, 首先拿到本地icon



在进行加水印文字, 覆盖第一个路径里.

PATH=${PATH}:/usr/local/bin

IPA_PATH=&quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/AppIcon60x60@2x.png&quot;

LOCAL_PATH=$(find ${SRCROOT} -name &quot;AppIcon60@2x.png&quot;)

convert &quot;${LOCAL_PATH}&quot; -fill black -font Times-Bold -pointsize 18 -gravity south -annotate 0 &quot;`date +%m-%d/%H:%m`&quot; &quot;${IPA_PATH}&quot;



添加到工程里



运行后发现已成功生成



目前更改的只是@2x图片, @3x图片并没有被改变, 在5.5寸屏没有效果, 为了替换多张, 就写个函数多次调用, 同时为了便于测试识别是哪天发的包, 使用 date +%m-%d/%H:%m 获取当前打包时间. 如下:

function changeIcon () {

PATH=${PATH}:/usr/local/bin

IPA_PATH=&quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/$1&quot;

LOCAL_PATH=$(find ${SRCROOT} -name $2)

convert &quot;${LOCAL_PATH}&quot; -fill black -font Times-Bold -pointsize 18 -gravity south -annotate 0 &quot;`date +%m-%d/%H:%m`&quot; &quot;${IPA_PATH}&quot;

}

changeIcon &quot;AppIcon60x60@2x.png&quot; &quot;AppIcon60@2x.png&quot;

changeIcon &quot;AppIcon60x60@3x.png&quot; &quot;AppIcon60@3x.png&quot;

changeIcon &quot;AppIcon40x40@2x.png&quot; &quot;AppIcon40@2x.png&quot;

changeIcon &quot;AppIcon40x40@3x.png&quot; &quot;AppIcon40@3x.png&quot;

changeIcon &quot;AppIcon29x29@2x.png&quot; &quot;AppIcon29@2x.png&quot;

changeIcon &quot;AppIcon29x29@3x.png&quot; &quot;AppIcon29@3x.png&quot;

changeIcon &quot;AppIcon20x20@2x.png&quot; &quot;AppIcon20@2x.png&quot;

changeIcon &quot;AppIcon20x20@3x.png&quot; &quot;AppIcon20@3x.png&quot;



如图, 已生成.


同时脚本可单独拿出去配合jenkins使用, 当构建的时候执行bash t.sh, 然后打包完成, 自动上传蒲公英, fir等第三方分发平台.

参考资料 http://merowing.info/2013/03/overlaying-application-version-on-top-of-your-icon/
</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>OCLint 代码自动检查</title>
      <url>/ios/2017/09/06/OCLint-%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5/</url>
      <content type="text">OCLint 代码自动检查

首先安装 OClint

终端执行 brew install oclint

创建 t.sh 脚本文件， 以下是代码

myworkspace=Gold.xcworkspace # 替换workspace的名字
myscheme=Gold # 替换scheme的名字
xcodebuild -workspace $myworkspace -scheme $myscheme clean&amp;amp;&amp;amp;
xcodebuild -workspace $myworkspace -scheme $myscheme \
-configuration Debug \
| xcpretty -r json-compilation-database -o compile_commands.json&amp;amp;&amp;amp;
oclint-json-compilation-database -e Pods -- \
-report-type html -o oclint_result.html \
-rc LONG_LINE=200 \
-max-priority-1=100000 \
-max-priority-2=100000 \
-max-priority-3=100000; \
rm compile_commands.json;
if [ -f ./oclint_result.html ]; then echo '-----分析完毕-----'
else echo &quot;-----分析失败-----&quot;; fi



终端执行 bash t.sh

执行完毕后如下图



同时生成.html文件,可直接在浏览器打开查看.



最方便的当然是 jenkins+oclint 自动构建, review.
</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>iOS多线程</title>
      <url>/ios/2017/08/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="text">dispatch_group_async

队列组, 异步执行, 等所有任务执行完毕, 会执行dispatch_group_notify, 这种之前应用场景是同时异步下载多张图片的操作, 等到所有图片现在完毕, 拿到图片进行拼接.

dispatch_group_t group = dispatch_group_create();

NSMutableArray *mua = [NSMutableArray array];

for (YSPatientModel *model in groupModel.members) {
    
    if (model.pic) {
        dispatch_group_enter(group);

        [[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:model.pic] options:0 progress:nil completed:^(UIImage* image, NSError* error, SDImageCacheType cacheType, BOOL finished, NSURL* imageURL) {
            if (image) {
                [mua addObject:image];
            }
//                        NSLog(@&quot;线程%@&quot;,[NSThread currentThread]);
            dispatch_group_leave(group);
        }];
        
    }
    
}

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    
    UIImage *resultImage = [UIImage composeHeaderImageWithConstrainWH:self.groupIconImg.bounds.size.width imagePathArray:mua backgroundColor:RGB(236, 236, 236)];
    self.groupIconImg.image = resultImage;
    
});



dispatch_barrier_async 栅栏

同一队列, 异步执行时，barrier块必须单独执行，不能与其他block并行。这只对并发队列有意义，并发队列如果发现接下来要执行的block是个barrier block，那么就一直要等到当前所有并发的block都执行完毕，才会单独执行这个barrier block代码块，等到这个barrier block执行完毕，再继续正常处理其他并发block。
dispatch_queue_t queue = dispatch_queue_create(&quot;Queue&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_async(queue, ^{
    NSLog(@&quot;----1-----%@&quot;, [NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;----2-----%@&quot;, [NSThread currentThread]);
});

//  都会等待在它前面插入队列的任务（1、2、）先执行完再执行后面的任务（3, 4）
dispatch_barrier_async(queue, ^{
    NSLog(@&quot;----barrier-----%@&quot;, [NSThread currentThread]);
});

dispatch_async(queue, ^{
    NSLog(@&quot;----3-----%@&quot;, [NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;----4-----%@&quot;, [NSThread currentThread]);
});



dispatch_semaphore 信号量

防止多个线程同时操作一块资源, 控制并发。dispatch_semaphore_create 可以理解为创建的信号总量，dispatch_semaphore_signal是发送一个信号，会让信号总量加1，dispatch_semaphore_wait等待信号，让信号总量-1，当信号总量少于等于0的时候就会一直等待，否则就可以正常的执行，可以创建一个并发控制。YYCache里有用到。

dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);
dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
// 异步3个线程访问2个资源, 只分配2个资源
    
//任务1
dispatch_async(quene, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;run task 1&quot;);
    
    dispatch_semaphore_signal(semaphore);
    NSLog(@&quot;complete task 1&quot;);
});
//任务2
dispatch_async(quene, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;run task 2&quot;);

    dispatch_semaphore_signal(semaphore);
    NSLog(@&quot;complete task 2&quot;);
});
//任务3
dispatch_async(quene, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;run task 3&quot;);

    dispatch_semaphore_signal(semaphore);
    NSLog(@&quot;complete task 3&quot;);
});


当然, 底下 NSLock锁 一样可以实现以上操作。

NSLock锁
NSLock *lock = [[NSLock alloc]init];
dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//任务1
dispatch_async(quene, ^{
    
    [lock lock];
    NSLog(@&quot;run task 1&quot;);
    sleep(5);
    
    [lock unlock];
    
    NSLog(@&quot;complete task 1&quot;);
});
//任务2
dispatch_async(quene, ^{
    
    [lock lock];
    NSLog(@&quot;run task 2&quot;);
    
    [lock unlock];
    NSLog(@&quot;complete task 2&quot;);
});
    
// 打印结果
//    2017-08-10 16:29:44.792 GCDSemaphore[8153:2775304] run task 1
//    2017-08-10 16:29:49.797 GCDSemaphore[8153:2775302] run task 2
//    2017-08-10 16:29:49.797 GCDSemaphore[8153:2775304] complete task 1
//    2017-08-10 16:29:49.797 GCDSemaphore[8153:2775302] complete task 2



当任务1锁住之后，任务2会一直等待5s后等任务1将锁设置为unlock后，才会执行run task 2。如果不unlock, 那么任务2永远不会执行
</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>php基本语法</title>
      <url>/php/2017/08/09/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="text">声明变量$, 打印echo

字符串

	&amp;lt;?php
	$text1 = '哈哈';
	$text2 = 'hello word';
	//  中间用.连接字符串
	echo $text1.&quot;    &quot;.$text2;
	echo strlen($text2);	// 计算字符串长度
	echo strpos($text2, 'w');	// 查找在字符串中的位置,返回第几位
	?&amp;gt;
	

数组

	&amp;lt;?php
	//  数组
	$arr = array('zhangsan','lisi','wangwu');
	
	sort($arr);  // 对数组进行排序 正序
	rsort($arr);	// 降序
	
	
	echo $arr[0];
	// 获取数组长度
	echo count($arr);
	
	$lenth = count($arr);
	for ($i=0; $i &amp;lt; $lenth; $i++) { 
		# code...
		echo $arr[$i];
	    echo PHP_EOL;
	}
	
	// 遍历普通数组
	$array = array('zhangsan','lisi','wangwu');
	foreach ($array as $key) {
		# code...
		echo $key.PHP_EOL;
	}
	?&amp;gt;
	

关联数组, 应该类似于ios字典

	&amp;lt;?php
	//  php关联数组
	$guanlianArr = array('zhangsan' =&amp;gt;'20' ,'lisi' =&amp;gt;'28','wangwu' =&amp;gt;'18' );
	
	// 根据数组的值，对数组进行升序排列
	asort($guanlianArr);
	arsort($guanlianArr); // 根据数组的值，对数组进行降序排列
	
	ksort($guanlianArr);	// 根据数组的键，对数组进行降序排列
	krsort($guanlianArr);	// 根据数组的键，对数组进行升序排列
	
	echo &quot;lisi is &quot;.$guanlianArr['lisi'].&quot; age&quot;;
	
	//  遍历关联数组,  
	foreach ($guanlianArr as $key =&amp;gt; $value) {
		# code...
		echo &quot;   name is &quot;.$key.&quot; age is &quot;.$value.&quot;    &quot;.PHP_EOL;
	}
	?&amp;gt;
	

if 语句

	&amp;lt;?php
	//  if  语句
	$time = 12;
	if ($time &amp;lt; 11) {
		# code...
		echo &quot;true&quot;;
	}elseif ($time &amp;lt; 20) {
		# code...
		echo &quot;false&quot;.$time;
	}else{
		echo &quot;false&quot;;
	}
	?&amp;gt;
	

switch

	&amp;lt;?php
	//  switch
	$color = &quot;red&quot;;
	
	switch ($color) {
		case 'red':
			# code...
			echo &quot;red&quot;;
			break;
		case 'blue':
			# code...
			echo &quot;blue&quot;;
			break;
	
		default:
			# code...
			break;
	}
	?&amp;gt;
	

数据库查询数据结果集，json格式化输出函数json_encode()，PHP 还有很强大的框架，ThinkPhp，任重而道远。
</content>
      <categories>
        
          <category> PHP </category>
        
      </categories>
      <tags>
        
          <tag> PHP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Mac上配置php</title>
      <url>/php/2017/08/05/mac%E4%B8%8A%E9%85%8D%E7%BD%AEphp/</url>
      <content type="text">Mac上配置php

mac自带apache, 打开终端

// 开启Apache服务  
sudo apachectl start  
// 查看Apache版本号  
sudo apachectl -v  



浏览器输入http://localhost, 会出现it works;

运行我们的php之前，我们需要更改我们的php配置文件，打开Finder，“前往-&amp;gt;前往文件夹…”，输入：

/etc/apache2/  



找到#LoadModule php5_module libexec/apache2/libphp5.so 把注释去掉

重启apache

sudo apachectl restart 



建一个index.php文件, 用编辑器打开写入



浏览器输入http://localhost/



创建数据库

	&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
	&amp;lt;?php
	$servername = &quot;127.0.0.1&quot;;
	$username = &quot;root&quot;;
	$password = &quot;123456&quot;;

	// 创建连接
	$conn = new mysqli($servername, $username, $password);
	// 检测连接
	if ($conn-&amp;gt;connect_error) {
    	die(&quot;连接失败: &quot; . $conn-&amp;gt;connect_error);
	} 

	// 创建数据库
	$sql = &quot;CREATE DATABASE test&quot;;
	if ($conn-&amp;gt;query($sql) === TRUE) {
    	echo &quot;数据库创建成功&quot;;
	} else {
    	echo &quot;Error creating database: &quot; . $conn-&amp;gt;error;
	}

	$conn-&amp;gt;close();
	?&amp;gt;
	

建表

	&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
	&amp;lt;?php
	$servername = &quot;127.0.0.1&quot;;
	$username = &quot;root&quot;;
	$password = &quot;123456&quot;;
	$dbname = &quot;test&quot;;

	// 创建连接
	$conn = new mysqli($servername, $username, $password, 	$dbname);
	// 检测连接
	if ($conn-&amp;gt;connect_error) {
    	die(&quot;连接失败: &quot; . $conn-&amp;gt;connect_error);
	} 

	// 使用 sql 创建数据表
	$sql = &quot;CREATE TABLE t_person (
	id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, 
	firstname VARCHAR(30) NOT NULL,
	lastname VARCHAR(30) NOT NULL,
	email VARCHAR(50),
	reg_date TIMESTAMP
	)&quot;;

	if ($conn-&amp;gt;query($sql) === TRUE) {
    	echo &quot;Table t_person created successfully&quot;;
	} else {
    	echo &quot;创建数据表错误: &quot; . $conn-&amp;gt;error;
	}

	$conn-&amp;gt;close();
	?&amp;gt;
	

如图


创建成功, 打开navicat查看
 

插入一条记录

	&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
	&amp;lt;?php
	$servername = &quot;127.0.0.1&quot;;
	$username = &quot;root&quot;;
	$password = &quot;123456&quot;;
	$dbname = &quot;test&quot;;

	// 创建连接
	$conn = new mysqli($servername, $username, $password, 	$dbname);
	// 检测连接
	if ($conn-&amp;gt;connect_error) {
    	die(&quot;连接失败: &quot; . $conn-&amp;gt;connect_error);
	} 

	$sql = &quot;INSERT INTO t_person (firstname, lastname, email)
	VALUES ('jay', 'chou', 'chou@example.com')&quot;;

	if ($conn-&amp;gt;query($sql) === TRUE) {
    	echo &quot;新记录插入成功&quot;;
	} else {
    	echo &quot;Error: &quot; . $sql . &quot;&amp;lt;br&amp;gt;&quot; . $conn-&amp;gt;error;
	}

	$conn-&amp;gt;close();
	?&amp;gt;
	

插入成功, 如下图所示


读取数据

	&amp;lt;?php
	$servername = &quot;127.0.0.1&quot;;
	$username = &quot;root&quot;;
	$password = &quot;123456&quot;;
	$dbname = &quot;test&quot;;
 
	// 创建连接
	$conn = new mysqli($servername, $username, $password, 	$dbname);
	// Check connection
	if ($conn-&amp;gt;connect_error) {
    	die(&quot;连接失败: &quot; . $conn-&amp;gt;connect_error);
	} 
 
	$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;
	$result = $conn-&amp;gt;query($sql);
 
	if ($result-&amp;gt;num_rows &amp;gt; 0) {
    	// 输出数据
    	while($row = $result-&amp;gt;fetch_assoc()) {
        	echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . 	$row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&amp;lt;br&amp;gt;&quot;;
    	}
	} else {
    	echo &quot;0 结果&quot;;
	}
	$conn-&amp;gt;close();
	?&amp;gt;
	

成功后如图


更新的操作
修改sql语句就行了

	UPDATE t_person SET email='kangbingbj@gmail.com' WHERE firstName='jay' AND lastname='chou'
	

删除记录

	DELETE FROM t_person WHERE firstname = 'julie'
	

这样环境基本已经OK，具体应用后期记笔记。
</content>
      <categories>
        
          <category> PHP </category>
        
      </categories>
      <tags>
        
          <tag> PHP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>在线预览PDF及office文件</title>
      <url>/ios/2017/07/28/%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88PDF%E5%8F%8Aoffice%E6%96%87%E4%BB%B6/</url>
      <content type="text">需求：线上生成电子合同，客户端预览。



这里提供三种方法，不仅限于pdf，经测试，office格式文件同样支持。第二三种方法只能浏览本地文件，所以线上的必须先下载在浏览。

第一种方法最简单方便，webView加载。不仅能加载本地，也能加载线上的。

代码如下:

UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];
webView.backgroundColor = [UIColor whiteColor];
NSURL *filePath = [NSURL URLWithString:[[NSBundle mainBundle] pathForResource:@&quot;pptdemo&quot; ofType:@&quot;pptx&quot;]];
NSURLRequest *request = [NSURLRequest requestWithURL: filePath];
[webView loadRequest:request];
[webView setScalesPageToFit:YES];
[self.view addSubview:webView];



第二种方法:本地的话，就直接加载bundle，返回url。线上的先下载到本地，再进行预览。

NSString *name = @&quot;demo.pdf&quot;;
// 检查本地是否存在
if ([self isFileExist:name]) {
    
    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    NSString *pathString = [path stringByAppendingFormat:@&quot;/%@&quot;,name];
    NSLog(@&quot;path:%@&quot;, pathString);
    self.pathString = pathString;
}else{
    
    //重新下载
    [self loadHttpPdfWithUrl:@&quot;http://192.168.1.25/demo.pdf&quot;];
    
}

// 方法2
QLPreviewController *QLPVC = [[QLPreviewController alloc] init];
self.QLPVC = QLPVC;
QLPVC.delegate = self;
QLPVC.dataSource = self;
[self presentViewController:QLPVC animated:YES completion:nil];



判断是否已经下载

- (BOOL)isFileExist:(NSString *)fileName{

    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;

    NSString *filePath = [path stringByAppendingPathComponent:fileName];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL result = [fileManager fileExistsAtPath:filePath];
    
    NSLog(@&quot;这个文件是否存在%d&quot;,result);
    return result;
}



下载的操作

- (void)loadHttpPdfWithUrl:(NSString *)url{

    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
    //请求
    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
    
    //下载Task操作
    _downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) {
        
        // totalUnitCount;     需要下载文件的总大小
        // completedUnitCount; 当前已经下载的大小
        NSLog(@&quot;%f&quot;,1.0 * downloadProgress.completedUnitCount / downloadProgress.totalUnitCount);

        
    } destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
        //返回的这个URL就是文件的位置的路径
        NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
        NSString *path = [documentPath stringByAppendingPathComponent:response.suggestedFilename];
        NSLog(@&quot;%@&quot;,path);
        return [NSURL fileURLWithPath:path];
        
    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
        //  下载完成
        NSString *localFilePath = [filePath path];// 将NSURL转成NSString
        self.pathString = localFilePath;
        NSLog(@&quot;已经下载完成的路径%@&quot;,localFilePath);
        // 下载完成刷新, 加载
        [self.QLPVC reloadData];
        NSLog(@&quot;%@&quot;,error);
        
    }];
    // 开始下载
    [_downloadTask resume];

}



实现代理方法

- (NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller{
    return self.pathString == nil ? 0 : 1;
}
- (id&amp;lt;QLPreviewItem&amp;gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index{
    // 加载本地
    //    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;pptdemo&quot; ofType:@&quot;pptx&quot;];
    //    return [NSURL fileURLWithPath:path];
    
    // 加载网络下载的, 其实也在本地沙盒了
    return [NSURL fileURLWithPath:self.pathString];;
}



第三种本地有就直接创建，实现代理方法。线上的下载完成以后创建控制器。实现与方法二类似。

NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;pptdemo&quot; ofType:@&quot;pptx&quot;];
UIDocumentInteractionController *docVC = [UIDocumentInteractionController interactionControllerWithURL:[NSURL fileURLWithPath:path]];
docVC.delegate = self;
[docVC presentPreviewAnimated:YES];



实现代理

#pragma mark 方法3代理
#pragma mark - UIDocumentInteractionControllerDelegate
- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller{
    
    return self;
}

- (UIView*)documentInteractionControllerViewForPreview:(UIDocumentInteractionController*)controller {
    
    return self.view;
}

- (CGRect)documentInteractionControllerRectForPreview:(UIDocumentInteractionController*)controller {
    return CGRectMake(0, 30, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height);
}



这里下载用的AFN，为了模拟测试，把文件放到本机apache了(mac自带)。电脑本机ip就是服务器地址。路径/Library/WebServer/Documents下。

代码已上传至 github

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>基于GPUImage的相机滤镜</title>
      <url>/ios/2017/07/25/%E5%9F%BA%E4%BA%8EGPUImage%E7%9A%84%E7%9B%B8%E6%9C%BA%E6%BB%A4%E9%95%9C/</url>
      <content type="text">相机滤镜如图



GPUImage 相机

GPUImage提供了丰富的滤镜，简单的说就是4步走，

1 初始化相机

// 相机使用 GPUImageStillCamera
self.videoCamera = [[GPUImageStillCamera alloc]initWithSessionPreset:AVCaptureSessionPresetHigh cameraPosition:AVCaptureDevicePositionBack];
self.videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;
self.videoCamera.horizontallyMirrorFrontFacingCamera = YES;



2 初始化滤镜

_mFilter = [[GPUImageStretchDistortionFilter alloc] init];



3 创建预览层并把滤镜输出至预览

self.filterView = [[GPUImageView alloc] initWithFrame:self.view.frame];
[_mFilter addTarget:self.filterView];



4 相机获取视频数据输出到滤镜

[self.videoCamera addTarget:_mFilter];
[self.videoCamera startCameraCapture];



切换滤镜的操作

// 移除之前滤镜
[self.videoCamera removeAllTargets];
_mFilter = (GPUImageFilter *)self.fillerArray[self.index % self.fillerArray.count];
[self.videoCamera addTarget:_mFilter];
[_mFilter addTarget:self.filterView];



基于GPUImga的相机滤镜



GPUImage 录像

// 录像使用GPUImageVideoCamera
videoCamera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPresetHigh cameraPosition:AVCaptureDevicePositionBack];

videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;
videoCamera.horizontallyMirrorFrontFacingCamera = NO;
videoCamera.horizontallyMirrorRearFacingCamera = NO;

filter = [[GPUImageSepiaFilter alloc] init];
[videoCamera addTarget:filter];
GPUImageView *filterView = [[GPUImageView alloc] initWithFrame:self.view.frame];
filterView.center = self.view.center;
[self.view addSubview:filterView];

NSString *pathToMovie = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents/Movie.m4v&quot;];
unlink([pathToMovie UTF8String]); // If a file already exists, AVAssetWriter won't let you record new frames, so delete the old movie
NSURL *movieURL = [NSURL fileURLWithPath:pathToMovie];
movieWriter = [[GPUImageMovieWriter alloc] initWithMovieURL:movieURL size:CGSizeMake(480.0, 640.0)];
movieWriter.encodingLiveVideo = YES;

[filter addTarget:movieWriter];
[filter addTarget:filterView];
[videoCamera startCameraCapture];
_movieURL = movieURL;



开始录像的操作

videoCamera.audioEncodingTarget = movieWriter;
[movieWriter startRecording];



结束录像并保存到相册

[filter removeTarget:movieWriter];
videoCamera.audioEncodingTarget = nil;
[movieWriter finishRecording];
NSLog(@&quot;Movie completed%@&quot;,_movieURL);

ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:_movieURL])
{
    [library writeVideoAtPathToSavedPhotosAlbum:_movieURL completionBlock:^(NSURL *assetURL, NSError *error)
     {
         dispatch_async(dispatch_get_main_queue(), ^{
             
             if (error) {
                 UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;错误&quot; message:@&quot;视频保存失败&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil];
                 [alert show];
             } else {
                 UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;成功&quot; message:@&quot;已保存到相册&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil];
                 [alert show];
             }
         });
     }];
}



基于GPUImga的录像滤镜



模仿微信相机


代码已上传至 github

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Charles 抓取 Https 数据</title>
      <url>/ios/2017/06/14/Charles-%E6%8A%93%E5%8F%96-Https-%E6%95%B0%E6%8D%AE/</url>
      <content type="text">下载
首先去下载 Charles，安装之后，

设置
查看本机 IP, 然后手机连接到同一个 WiFi，并且手动设置代理，服务器为刚才看的 IP，端口8888，如图

点击返回。连接成功后打开 Charles 就可以看到请求的数据了。如图：

但是如果是 https 就肯定就不行了，

Https
那就安装证书进行如图操作


点击后出现弹框

这时候打开手机 Safari， 地址栏输入 chls.pro/ssl, 安装描述文件就可以了，这个我已经安装过了。


这是再次打开发现还是获取不到https数据，来进行下一步操作。


按照下图操作。


点击添加，把知乎的 URL 填进去，端口443；点击 OK， 确定


这时候已经大功告成啦。


有问题随时留言。

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>AppStore Review</title>
      <url>/ios/2017/05/23/AppStore-Review/</url>
      <content type="text">前言
最近项目要更新版本，然而以为会跟往常一样，提交后2-3天通过，结果这次可没有没有那么顺利了，两个客户端一起提交上去，相继悲剧。

患者端
并且患者端是一个没有见过的原因 PLA1.2, 邮件原文如下。

发件人 Apple
PLA 1.2


The seller and company names associated with your app do not reflect the medical institution in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.

Apps with medical consultation features must be publish by the medical institution.

Next Steps

Your app must be published under a seller name and company name that reflects the medical institution. If you have developed these apps on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.

Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.




其中有一句然我看到很绝望，说具有医疗咨询功能的应用必须有医疗机构发布，PS:我们应用是和医院合作的，这让医院发布感觉不太现实啊。网上检索了一下，都说最近这种情况很多，金融、P2P、电商，医疗是重灾区。有的说是因为 app 和公司发布账号没有直接性联系，上传下商标软著之类的都给过了，有的是上传的营业执照，五花八门，有的被拒了4，5次过了，有的是把个人账号改成公司账号就行了，可是我们本来就是公司账号。

最后没办法，我也尝试着在邮件内回复，说明软件的目的，并且和和医院的合作协议什么的都上传了，然而第二天收到这样的回复。


发件人 Apple
Hello,

Thank you for your response.

Regarding the PLA 1.2 issue, since you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account and upload the app in that account.

Best regards,

App Store Review




这么看并没有什么用啊，还是要求医院账号发布，把我们账号添加到他们团队里，怎么解决？解决方案？尝试重新打包发布，同样的原因再次被拒。上周四我给Review团队回复了邮件，要求他们电话给我沟通，看怎么解决。他们回复3个工作日内回复我。这周二(今天），早上8点57，一个看起来像虚拟电话的号码打进来，接听手说是Review团队，听起来口音英应该不是大陆这面的（但肯定也不是美国的），应该是香港的，她简单给我描述了下我的问题。大概意思是唯一的解决方案就是要求合作医院的账号来发布这个应用， 什么合同，协议，执照，都不行。那我问像春雨，好大夫，平安好医生，这些问诊类应用怎么不受影响。他说的有句话是重点——他们是平台，上面有很多家医院的医生，属平台性质。但是我们也是平台啊，这我才有一点点明白，这个版本被拒是因为应用里面频繁提及合作医院的名字，让审核团队就是觉得这个应用就是给他们定制的，没有体现出是一个平台。

医生端
同时医生端的应用就有意思了，患者端悲剧的第二天收到医生端被拒的消息，如下：

发件人 Apple

    2. 1 Performance: App Completeness

Guideline 2.1 - Performance


We discovered one or more bugs in your app when reviewed on iPhone running iOS 10.3.2 on Wi-Fi connected to an IPv6 network.

Specifically, we could not log in. Your app did not respond to produce any further actions when tapped on the login button.

Please see attached screenshots for details.

Next Steps

To resolve this issue, please run your app on a device while connected to an IPv6 network (all apps must support IPv6) to identify any issues, then revise and resubmit your app for review.

If we misunderstood the intended behavior of your app, please reply to this message in Resolution Center to provide information on how these features were intended to work.

For new apps, uninstall all previous versions of your app from a device, then install and follow the steps to reproduce the issue. For updates, install the new version as an update to the previous version, then follow the steps to reproduce the issue.

Resources

For information about supporting IPv6 Networks, please review Supporting IPv6 DNS64/NAT64 Networks and About Networking.




大概就是说应用不支持 IPV6，登陆不进去。这问题比患者端的 PLA1.2好解决啊，立刻开始在本地搭建 IPV6环境，测试后并没有什么问题。检索了一下，我觉得在网不好的情况下，或者审核团队没有成功登陆之类这些问题被拒原因基本都会是 IPV6，其实原因并不是，只是他们不能正常使用你应用。

代码一行没有改，还是之前的哪个 ipa 包，再次提交审核，这次没有在底下回复，而是重新提交审核了，隔了大概两天，收到这样的回复

发件人 Apple
Guideline 2.5.4 - Performance - Software Requirements


Your app declares support for VoIP in the UIBackgroundModes key in your Info.plist, but it does not include any Voice over IP services.

Next Steps

To resolve this issue, please revise your app to either add VoIP features or remove the &quot;voip&quot; setting from the UIBackgroundModes key.

We recognize that VoIP can provide &quot;keep alive&quot; functionality that is useful for many app features. However, using VoIP in this manner is not the intended purpose of VoIP.

Request a phone call from App Review

At your request, we can arrange for an Apple Representative to call you within the next three business days to discuss your App Review issue.

To request a call and ensure we have accurate contact information, reply directly to this message with a contact name and direct phone number to reach you.




是说我应用里开启了 VoIP 功能，能后台唤醒，但是从程序里并没有找到哪个功能支持 VoIP，其实程序功能这个版本已经实现了。于是就截了两张图，传过去了。今天早上一看，成功了。怪不得有的人都说，发版的时候，录好一段使用视频，传到 Youtube，提交审核的时候给审核人员看，有利于过审，不无道理啊。

患者端已更改上传，最后结果还不明朗。PS：最近做梦有时候都梦到审核团队给我回邮件。。。。。

2017-5-27  –更新—

由于更换账号时间成本太高，于是只能从产品本身解决问题。从一开始，产品定位就是一个平台，但是由于医院合作紧密，导致频繁提及，那就从产品本身体现平台吧，优化修改了首页，以及相关协议，细节，周四改完，周五提交，今天（周六）中午，通过了。。。。。。

最后端午小长假要来了。

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>一步一步带你实现 iOS 直播 Demo</title>
      <url>/ios/2017/03/28/iOS%E7%9B%B4%E6%92%AD-Demo/</url>
      <content type="text">
  推流:LFLiveKit		播放:ijkplayer	服务器:nginx+rtmp


首先开发一款直播 APP 首先是播放, 前提是服务器只要提供拉流的 url, 下面就主要是通过ijkplayer, 来实现播放;
直播源, 也就是 url 是从映客抓的, 直接上代码

- (void)loadData{

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, @&quot;text/plain&quot;, @&quot;text/html&quot;, nil];
[manager GET:@&quot;http://116.211.167.106/api/live/aggregation?uid=23455&amp;amp;interest=1&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
    
    if ([responseObject[@&quot;error_msg&quot;] isEqualToString:@&quot;操作成功&quot;]) {
        self.dataArray = [LiveModel mj_objectArrayWithKeyValuesArray:responseObject[@&quot;lives&quot;]];
        [self.tableView reloadData];
    }
} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
    
    NSLog(@&quot;%@&quot;,error);
}];
}



有了数据源, 实现 tableView 代理方法即可, 如下图:


Gif图



接下来就是比较重要的一步, 实现播放, 去下载ijkplayer


下载完成之后, cd到当前文件夹下, 执行命令./init-ios.sh然后会等很久,等下载完成之后



我们cd 到 ios 文件夹执行命令./compile-ffmpeg.sh clean


再执行./compile-ffmpeg.sh all
编译时间较长。


完成之后打包IJKMediaFramework.framework框架


  首先打开工程IJKMediaPlayer.xcodeproj, 位置如下图: 
  打开之后,去修改 scheme -&amp;gt; run -&amp;gt; release
  模拟器下 command+b 编译下
  真机下 command+b 编译 
  然后展开 Product 文件夹 如图 Show In Finder
  lipo -create “真机路径” “模拟器路径” -output “合并后的文件路径”注意合并后问价的命名,如下图
  将Release-iphoneos里面的IJKMediaFramework删掉;
  把刚生成的IJKMediaFramework拖到Release-iphoneos/IJKMediaFramework.framework/文件夹下
  这样IJKMediaFramework.framework就是我们需要的了如图
  将其添加到项目中并添加相关的库


Build Phases -&amp;gt; Link Binary with Libraries -&amp;gt; Add:
IJKMediaFramework.framework

AudioToolbox.framework

AVFoundation.framework

CoreGraphics.framework

CoreMedia.framework

CoreVideo.framework

libbz2.tbd

libz.tbd

MediaPlayer.framework

MobileCoreServices.framework

OpenGLES.framework

QuartzCore.framework

UIKit.framework

VideoToolbox.framework 



播放代码

[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(didChangeNotification:) name:IJKMPMoviePlayerPlaybackStateDidChangeNotification object:nil];

[self loadingImgView];

IJKFFOptions *options = [IJKFFOptions optionsByDefault];
// 硬解
//    [options setPlayerOptionIntValue:1  forKey:@&quot;videotoolbox&quot;];
//    // 帧速率(fps) （可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）
//    [options setPlayerOptionIntValue:29.97 forKey:@&quot;r&quot;];
//    // -vol——设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推
//    [options setPlayerOptionIntValue:512 forKey:@&quot;vol&quot;];
// 去掉缓冲区
//    [options setPlayerOptionIntValue:0 forKey:@&quot;packet-buffering&quot;];

NSURL *url = [NSURL URLWithString:self.stream_addr];
IJKFFMoviePlayerController *playerVc = [[IJKFFMoviePlayerController alloc] initWithContentURL:url withOptions:options];
[playerVc prepareToPlay];
_playerVc = playerVc;
playerVc.view.frame = [UIScreen mainScreen].bounds;
[self.view addSubview:playerVc.view];



效果如图:


IJKMediaFramework已上传百度云
IJKMediaFramework.framework 下载  密码: uvha

推流篇

播放已完成, 那下面需要直播了, 直播首先在本地nginx搭建rtmp协议流媒体服务器;


  安装Homebrew, 也就是在 OSX 上软件包管理工具;
  如果没有安装输入以下命令安装ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”, 利用 man brew 可以查询本机是否安装;
  安装完成之后, 那就利用 Homebrew 安装 nginx, 终端输入: brew tap homebrew/nginx;
  下载nginx-rtmp-module模块, 执行命令brew install nginx-full –with-rtmp-module;
  输入nginx, 打开http://localhost:8080, 如下图所示, 说明环境搭建好了;
  修改配置文件, 先去查看 nginx 配置文件, 终端输入brew info nginx-full;
  去搜索 Command+F 查找nginx.conf, 如图:
  把路径复制下, finder前往文件夹, 粘贴路径找到配置文件, 用编辑器打开, 如图:
  在上图位置添加如下代码:


rtmp {
    server {
        listen 1935;
        application rtmplive {
            live on;
            record off;
        }
    }
}


rtmp:协议名, server:服务器配置, listen:监听的端口号, application应用名称, live:开启实时;
配置完成之后记得刷新, 也就是重新加载配置文件 终端输入: nginx -s reload

以上推流就准备就绪, 但是由于是本地测试, 不在外网, 那想要查看自己直播, 需要一个播放器了; 去下载 VLC

音视频采集

下面就要去项目进行客户端采集音视频;
利用 pod 管理, Podfile 里 添加pod 'LFLiveKit' 即可, 当然你也可以不用 pod 直接添加也行; 并添加相关依赖库之后, 看代码实现:

- (LFLiveSession *)session {
if (!_session) {

    /***   默认分辨率368 ＊ 640  音频：44.1 iphone6以上48  双声道  方向竖屏 ***/
    LFLiveVideoConfiguration *videoConfiguration = [LFLiveVideoConfiguration new];
    videoConfiguration.videoSize = CGSizeMake(360, 640);
    videoConfiguration.videoBitRate = 800*1024;
    videoConfiguration.videoMaxBitRate = 1000*1024;
    videoConfiguration.videoMinBitRate = 500*1024;
    videoConfiguration.videoFrameRate = 24;
    videoConfiguration.videoMaxKeyframeInterval = 48;
    videoConfiguration.outputImageOrientation = UIInterfaceOrientationPortrait;
    videoConfiguration.autorotate = NO;
    videoConfiguration.sessionPreset = LFCaptureSessionPreset720x1280;
    _session = [[LFLiveSession alloc] initWithAudioConfiguration:[LFLiveAudioConfiguration defaultConfiguration] videoConfiguration:videoConfiguration captureType:LFLiveCaptureDefaultMask];

    _session.delegate = self;
    _session.showDebugInfo = NO;
    _session.preView = self;
    
    
}
return _session;
}		



开启音视频

- (void)requestAccessForVideo {
__weak typeof(self) _self = self;
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];
switch (status) {
case AVAuthorizationStatusNotDetermined: {
    // 许可对话没有出现，发起授权许可
    [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
            if (granted) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [_self.session setRunning:YES];
                });
            }
        }];
    break;
}
case AVAuthorizationStatusAuthorized: {
    // 已经开启授权，可继续
    dispatch_async(dispatch_get_main_queue(), ^{
        [_self.session setRunning:YES];
    });
    break;
}
case AVAuthorizationStatusDenied:
case AVAuthorizationStatusRestricted:
    // 用户明确地拒绝授权，或者相机设备无法访问

    break;
default:
    break;
	}
}

- (void)requestAccessForAudio {
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];
switch (status) {
case AVAuthorizationStatusNotDetermined: {
    [AVCaptureDevice requestAccessForMediaType:AVMediaTypeAudio completionHandler:^(BOOL granted) {
        }];
    break;
}
case AVAuthorizationStatusAuthorized: {
    break;
}
case AVAuthorizationStatusDenied:
case AVAuthorizationStatusRestricted:
    break;
default:
    break;
   }
}



相关状态代理方法

- (void)liveSession:(nullable LFLiveSession *)session liveStateDidChange:(LFLiveState)state {
NSLog(@&quot;liveStateDidChange: %ld&quot;, state);
switch (state) {
case LFLiveReady:
    _stateLabel.text = @&quot;准备中&quot;;
    break;
case LFLivePending:
    _stateLabel.text = @&quot;连接中&quot;;
    break;
case LFLiveStart:
    _stateLabel.text = @&quot;已连接&quot;;
    break;
case LFLiveError:
    _stateLabel.text = @&quot;连接错误&quot;;
    break;
case LFLiveStop:
    _stateLabel.text = @&quot;直播已结束&quot;;
    break;
default:
    break;
	}
}


- (void)liveSession:(nullable LFLiveSession *)session debugInfo:(nullable LFLiveDebug *)debugInfo {
NSLog(@&quot;debugInfo uploadSpeed: %@&quot;, formatedSpeed(debugInfo.currentBandwidth, debugInfo.elapsedMilli));
}


- (void)liveSession:(nullable LFLiveSession *)session errorCode:(LFLiveSocketErrorCode)errorCode {
NSLog(@&quot;errorCode: %ld&quot;, errorCode);
}



开始直播的操作

LFLiveStreamInfo *stream = [LFLiveStreamInfo new];
//  推流地址
stream.url = @&quot;rtmp://192.168.1.115:1935/rtmplive/room&quot;;
[self.session startLive:stream];



url 里192.168.1.115 是电脑本机的地址, 1935 就是我们上面 Nginx 的第9步, listen就是监听的端口号,  填写正确即可开始直播; 
打开本机服务器, 终端输入 nginx  这是进入我要直播界面是未连接的状态, 如图:


点击开始直播, 连接成功, 状态如图:


接下来就可以打开刚刚下载的 VLC 查看了; url输入我们本地地址

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Objective-C Runtime</title>
      <url>/ios/2017/03/22/Runtime/</url>
      <content type="text">Runtime 是什么？
Runtime 是 Objective-C 区别 C 语言等静态语言的一个非常重要的特性。对于 C 语言，函数的调用会在编译期就已经决定好，在编译完成后直接顺序运行。但是 OC 是一门动态语言，函数调用变成了消息转发，在编译阶段是不知道要调用哪个函数。所以 Runtime 无非就是去解决如何在运行时期找到调用方法这样的问题。
对于实例变量：

  instance -&amp;gt; class -&amp;gt; method -&amp;gt; SEL -&amp;gt; IMP -&amp;gt; 函数方法


实例对象中存放 isa 指针以及实例变量，有 isa 指针可以找到实例对象所属的类对象，类中存放着方法列表，在这个方法列表中 SEL 最为 key，IMP 作为 value。在编译时期，根据方法名字会生成一个唯一的 Int 标识，这个标识就是 SEL，IMP就是函数指针指向最终函数的实现。整个 Runtime 的核心就是 objc_msgSend 函数，通过给类发送 SEL 传递消息，找到 IMP 获取最终的实现。
下图描述了对象的内存布局


类中的 super_class 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上至根类（NSObject）中寻找 SEL 所对应的方法，找到后就运行整个方法。

metaClass 是元类，也有 isa 指针，super_class 指针。其中保存了累方法列表。

#import &amp;lt;objc/runtime.h&amp;gt;

SEL 与 IMP

SEL 可以将其理解为方法的 ID，结构如下：

typedef struct objc_selector *SEL;

struct objc_selector {
	char *name;                       OBJC2_UNAVAILABLE;
	char *types;                      OBJC2_UNAVAILABLE;
};



IMP 可以理解为函数指针，指定了最终的实现。
SEL 与 IMP 的关系非常类似于 HashTable 中 key 与 value 的关系，OC 中不支持函数重载的原因就是因为一个类的方法列表中不能存在两个相同的 SEL。但是多个方法可以在不同的类中有一个相同的 SEL，不同的类的实例对象执行相同的 SEL 时，会在各自的方法列表中去根据 SEL 去寻找自己对应的 IMP。这使得 OC 可以支持函数重写。

消息传递机制


  objc_msgSend函数的消息处理过程
  不涵盖消息cache机制
  需要对Objective-C runtime有一定的了解


objc_msgSend 函数的调用流程：


  检测 SEL 是否应该被忽略；
  检测发送的 target 是否为 nil，如果是则忽略该消息；
  


 	- 当调用实例方法时，通过 isa 指针找到实例对应的 class 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类 NSObject；

  当调用类方法时，通过 isa 指针找到实例对应的 metaclass 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject）
  如果还没有找到就进入消息动态解析过程。


当一个对象 sender 调用代码 [receuver message]; 的时候，实际上市调用了 runtime 的objc_msgSend函数。 所以 OC 的方法调用不是 C 语言那样，能按照地址直接取，而是经过了一系列过程。这样使得 runtime 可以在接收消息后进行特殊处理。这样就是 OC 具有一些特性，比如：给 nil 发消息不崩溃，给类添加方法和消息转发。也正是因为每一次调用方法的时候实际上是调用了一些 runtime 的消息处理函数，OC 的方法调用相比 C 来说会相对较慢。但 OC 也通过引入 cache 机制来很大程度上的克服了这个缺点。下面我们就从一个对象 sender 调用代码[receiver message];这个情景开始，了解消息传递的过程。

首先这行代码会被改写成objc_msgSend(self,_cmd);, 这是一个 runtime 的函数, 其原型为:

id objc_msgSend(id self,SEL op, ...)



slef 与 _cmd 是两个编辑器会自动添加的隐藏参数, self 是一个指向接收指针的对象, _cmd为方法选择器。这个函数的实现为汇编版本, 苹果开源项目中共有6种对不同平台的汇编实现, 本节选取其在 x86_64实现的文件 objc-msg-x86_64.s

#objc-msg-x86_64.s#
	ENTRY	_objc_msgSend
	// ...
	GetIsaFast NORMAL		// r11 = self-&amp;gt;isa
	CacheLookup NORMAL		// calls IMP on success
	// ...
// cache miss: go search the method lists
LCacheMiss:
	// isa still in r11
	MethodTableLookup %a1, %a2	// r11 = IMP
	cmp	%r11, %r11		// set eq (nonstret) for forwarding
	jmp	*%r11			// goto *imp
	END_ENTRY	_objc_msgSend


可以看到其调用了GetIsaFast，由于self是id类型，而id的原型为struct objc_object *id;，所以需要通过id的isa指针获取其所属的类对象，之后调用CacheLookup在获取到的类中根据传入的_cmd查找对应方法实现的IMP指针。这两个函数的实现均在同一个文件下，因为暂时我还不了解cache的机制，所以这部分先不深入讨论。CacheLookup函数在命中后会直接调用相应的IMP方法，这就完成了方法的调用。如果cache落空，则跳转至LCacheMiss标签，调用MethodTableLookup方法，这个方法将IMP的值存在r11寄存器里，之后jmp *%r11从IMP开始执行，完成方法调用。MethodTableLookup函数实现如下，

.macro MethodTableLookup
	MESSENGER_END_SLOW
	SaveRegisters
	// _class_lookupMethodAndLoadCache3(receiver, selector, class)
	movq	$0, %a1
	movq	$1, %a2
	movq	%r11, %a3
	call	__class_lookupMethodAndLoadCache3
	// IMP is now in %rax
	movq	%rax, %r11
	RestoreRegisters
.endmacro


可以看到其实际上将receiver（即self)， selector(即_cmd)，class(即self-&amp;gt;isa)传递给了_class_lookupMethodAndLoadCache3这个函数，查看该函数的实现后，欢迎重新回到C语言的世界。

#objc-class-old.mm#
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{        
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}


这个函数进一步调用了lookUpImpOrForward，并把cache标签置为NO，意味着忽略第一次不加锁的cache查找。这个函数的返回值要么是对应方法的IMP指针，要么是一个__objc_msgForward_impcache汇编方法的入口，后者对应着消息转发机制，即如果在该对象及其继承链上方的的对象都找不到选择器_cmd的响应方法的话，就调用消息转发函数尝试将该消息转发给其他对象。下面是lookUpImpOrForward的实现，由于代码过长，注释将写在代码之中。

#objc-class-old.mm#
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    Class curClass;                   // 当前类对象
    IMP methodPC = nil;               // 用于保存最终查找到的函数指针并返回
    Method meth;                      // 定义了方法的一个结构体，可通过meth-&amp;gt;imp获取函数指针
    bool triedResolver = NO;          // 方法解析的标志变量

    methodListLock.assertUnlocked();
    // 不加锁地查找cache，由于之前cache落空，所以肯定找不到，就忽略
    // Optimistic cache lookup                
    if (cache) {
        methodPC = _cache_getImp(cls, sel);
        if (methodPC) return methodPC;    
    }
    // Check for freed class
    if (cls == _class_getFreedObjectClass())
        return (IMP) _freedHandler;
    // 确保该类已被初始化，如果没有就调用类方法+initialize，这里也说明了为什么OC的类会在
    // 第一次接收消息后调用+initialize进行初始化，相反的，如果想要代码在类注册runtime的
    // 时候就运行，可以将代码写在+load方法里
    // Check for +initialize
    if (initialize  &amp;amp;&amp;amp;  !cls-&amp;gt;isInitialized()) {
        _class_initialize (_class_getNonMetaClass(cls, inst));
        // If sel == initialize, _class_initialize will send +initialize and 
        // then the messenger will send +initialize again after this 
        // procedure finishes. Of course, if this is not being called 
        // from the messenger then it won't happen. 2778172
    }
    // The lock is held to make method-lookup + cache-fill atomic 
    // with respect to method addition. Otherwise, a category could 
    // be added but ignored indefinitely because the cache was re-filled 
    // with the old value after the cache flush on behalf of the category.
    // 上述英文已述：对消息查找和填充cache加锁，由于填充cache是写操作，所以需要对其
    // 加锁以免加入了category之后的cache被旧的cache冲掉，导致category失效。

    // 实际上，如果cache没有命中，但在方法列表中找到了对应的IMP，函数也是会进行cache
    // 写入操作。
 retry:
    methodListLock.lock();
    // 在开启GC选项后忽略retain, release等方法(猜测GC 是 Garbage Collection)
    // 这也体现了OC的灵活性，runtime完全有权力忽略一些方法
    if (ignoreSelector(sel)) {
        methodPC = _cache_addIgnoredEntry(cls, sel);
        goto done;
    }
    // 在加锁的状态下再查找一次cache，如果命中就直接返回IMP指针
    // 个人认为再次在加锁状态下查找是因为在与上次查找的间隙中可能
    // 有其他类填充了这个cache
    methodPC = _cache_getImp(cls, sel);
    if (methodPC) goto done;

    // 如果还是没有命中的话就查找该类的方法列表
    meth = _class_getMethodNoSuper_nolock(cls, sel);
    if (meth) {
    	// 命中，填充cache，返回IMP指针
        log_and_fill_cache(cls, cls, meth, sel);
        methodPC = method_getImplementation(meth);
        goto done;
    }

    // 没有命中，沿着class的继承链向上查找，最后找到的是NSObject(NSProxy除外)
    // 而NSObject的superclass为nil
    curClass = cls;
    while ((curClass = curClass-&amp;gt;superclass)) {
        // 尝试从超类的cache中加载
        meth = _cache_getMethod(curClass, sel, _objc_msgForward_impcache);
        if (meth) {
        	// 如果不是forward
            if (meth != (Method)1) {
                // 在超类中找到IMP，在当前类中进行cache
                log_and_fill_cache(cls, curClass, meth, sel);
                methodPC = method_getImplementation(meth);
                goto done;
            }
            else {
            // 找到forward，跳出循环
                // Found a forward:: entry in a superclass.
                // Stop searching, but don't cache yet; call method 
                // resolver for this class first.
                break;
            }
        }
        // 超类cache没有命中，从超类的方法列表寻找
        meth = _class_getMethodNoSuper_nolock(curClass, sel);
        if (meth) {
            log_and_fill_cache(cls, curClass, meth, sel);
            methodPC = method_getImplementation(meth);
            goto done;
        }
    }
    // 使用方法解析并再尝试一次
    if (resolver  &amp;amp;&amp;amp;  !triedResolver) {
        methodListLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        triedResolver = YES;
        goto retry;
    }
    // 没有找到IMP指针，方法解析也没有用，使用消息转发，并将其填充入cache
    _cache_addForwardEntry(cls, sel);
    methodPC = _objc_msgForward_impcache;
 done:
    methodListLock.unlock();
    // paranoia: look for ignored selectors with non-ignored implementations
    assert(!(ignoreSelector(sel)  &amp;amp;&amp;amp;  methodPC != (IMP)&amp;amp;_objc_ignored_method));
    return methodPC;
}



我们可以看到每一个类都维护了一个cache，在一个对象调用runtime的objc_msgSend函数后，runtime在接收者所属的类的cache中查找与_cmd所对应的IMP，如果没有命中就寻找当前类的方法列表，再找不到就跳入while循环寻找超类的cache和方法列表，如果这些方法都失效，就调用_class_resolveMethod查找正在插入这个类的方法，之后再重新尝试整一个流程，如果最后还是没能找到一个对应的IMP，则调用消息转发机制。

动态消息解析



如下用于描述动态消息解析的流程:


  1.通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。
  2.这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。
  3.这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 unrecognized selector sent to instance，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 unrecognized selector sent to instance.


可以利用 2、3 中的步骤实现对接受消息对象的转移，可以实现“多重继承”的效果。

参考资料

  http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/
  http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html
  https://github.com/opensource-apple/objc4


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Runloop</title>
      <url>/ios/2017/03/09/Runloop/</url>
      <content type="text">Runloop

Runloop 是和线程紧密相关的基础组件，是很多线程有关功能的幕后功臣。平常几乎不太使用到，但是理解 Runloop 更有利于更加深入理解 iOS 多线程模型；

Runloop 基本概念
Runloop 是什么？Runloop 说白了就是一种循环，只不过这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 Runloop 则是一种闲等待，这部分可以类比 Linux 下的 epoll。当没有事件时，Runloop 会进入休眠状态，有时间发生时，Runloop 回去找对应的 handler（消息处理） 处理事件。Runloop 可以让线程在需要做事的时候忙起来，不需要的话就会让线程休眠。

引用苹果官方文档图，看 Runloop 的工作模式：


图中展现了 Runloop 在线程中的作用，从 input source 和 timer source 接受事件，然后在线程中处理事件。

Input Source 和 Timer Source
这两个都是事件的来源， 其中 Input Source 又可以分为三类


  Port-Based Sources，系统底层的 Port 事件，例如 CFSocketRef，在应用层基本用不到；
  Custom Input Sources，用户手动创建的 Source；
  Cocoa Perform Selector Sources, Cocoa 提供的performSelector 系列方法，也是一种事件源；


Timer Source 那就是指定时器事件了；

Runloop Observer
Runloop 通过监控 Source 来决定有没有任务要做，除此之外，我们还可以用 Runloop Observer 来监控 Runloop 本身的状态。Runloop Observer 可以监控下面的 runloop 事件：


  The entrance to the run loop.
  When the run loop is about to process a timer.
  When the run loop is about to process an input source.
  When the run loop is about to go to sleep.
  When the run loop has woken up, but before it has processed the event that woke it up.
  The exit from the run loop.


Runloop Mode
在监视与被监视中，Runloop 要处理的事情还挺复杂的，为了让 Runloop 能专心的处理自己关心的那部分事情，引入了 Runloop Mode 概念。



上图，Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Obersver 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Obersver。

官方文档中提到的 Mode 有5个，分别是：


  NSDefaultRunLoopMode
  NSConnectionReplyMode
  NSModalPanelRunLoopMode
  NSEventTrackingRunLoopMode
  NSRunLoopCommonModes


iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。
NSRunLoopCommonModes 就是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。

与 Runloop 相关的坑
平常开发中，用到 Runloop 接触的最近的就是 NSTimer 了。一个 Timer 一次只能加入到一个 Runloop 中。我们平时用的时候，通常就是加入到当前的 Runloop 的 NSDefaultRunLoopMode 中，而 ScrollView 在用户滑动时， 主线程 RunLoop 会转到 UITrackingRunLoopMode，这个时候， Timer 就不会运行了。
怎么办？ 两种解决方案：


  第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。
  第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。


相关代码：


	_graceTimer = [NSTimer timerWithTimeInterval:5.f target:self selector:@selector(updateViewControllersCaches) userInfo:nil repeats:YES];
	[[NSRunLoop mainRunLoop] addTimer:_graceTimer forMode:NSDefaultRunLoopMode];
	


这里就是添加了一个计时器，由于指定了 NSRunLoopCommonModes，所以不管 RunLoop 出于什么状态，都执行这个计时器任务。

参考资料


  https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1
  http://www.hrchen.com/2013/07/tricky-runloop-on-ios/
  http://www.cocoachina.com/ios/20150601/11970.html
  http://www.cocoachina.com/ios/20111111/3487.html


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>关联对象 AssociatedObject</title>
      <url>/ios/2017/03/06/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1-AssociatedObject/</url>
      <content type="text">我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 @property 并不能在分类中正确创建实例变量和存取方法。

不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。

写在前面

这篇文章包含了两方面的内容：


  使用关联对象为已经存在的类中添加属性
  关联对象在底层 Objective-C 中的实现



  注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。

  如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从这里开始深入了解其底层实现。


关联对象的应用

关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。

分类中的 @property

@property 可以说是一个 Objective-C 编程中的“宏”，它有元编程的思想。

@interface DKObject : NSObject

@property (nonatomic, strong) NSString *property;

@end


在使用上述代码时会做三件事：


  生成实例变量 _property
  生成 getter 方法 - property
  生成 setter 方法 - setProperty:


@implementation DKObject {
    NSString *_property;
}

- (NSString *)property {
    return _property;
}

- (void)setProperty:(NSString *)property {
    _property = property;
}

@end


这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 @property 生成一个属性，那么为什么在分类中不可以呢？

我们来做一个小实验：创建一个 DKObject 的分类 Category，并添加一个属性 categoryProperty：

@interface DKObject (Category)

@property (nonatomic, strong) NSString *categoryProperty;

@end


看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告：



在这里的警告告诉我们 categoryProperty 属性的存取方法需要自己手动去实现，或者使用 @dynamic 在运行时实现这些方法。

换句话说，分类中的 @property 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。

使用关联对象

Q：我们为什么要使用关联对象？

A：因为在分类中 @property 并不会自动生成实例变量以及存取方法，所以一般使用关联对象为已经存在的类添加『属性』。

上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个伪属性：

#import &quot;DKObject+Category.h&quot;
#import &amp;lt;objc/runtime.h&amp;gt;

@implementation DKObject (Category)

- (NSString *)categoryProperty {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setCategoryProperty:(NSString *)categoryProperty {
    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end



  这里的 _cmd 代指当前方法的选择子，也就是 @selector(categoryProperty)。


我们使用了两个方法 objc_getAssociatedObject 以及 objc_setAssociatedObject 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。

在这里有必要解释两个问题：


  为什么向方法中传入 @selector(categoryProperty)？
  OBJC_ASSOCIATION_RETAIN_NONATOMIC 是干什么的？


关于第一个问题，我们需要看一下这两个方法的原型：

id objc_getAssociatedObject(id object, const void *key);
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);


@selector(categoryProperty) 也就是参数中的 key，其实可以使用静态指针 static void * 类型的参数来代替，不过在这里，笔者强烈推荐使用 @selector(categoryProperty) 作为 key 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性。

OBJC_ASSOCIATION_RETAIN_NONATOMIC 又是什么呢？如果我们使用 Command 加左键查看它的定义：

typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**&amp;lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&amp;lt; Specifies that the associated object is copied. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&amp;lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&amp;lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};


从这里的注释我们能看到很多东西，也就是说不同的 objc_AssociationPolicy 对应了不通的属性修饰符：


  
    
      objc_AssociationPolicy
      modifier
    
  
  
    
      OBJC_ASSOCIATION_ASSIGN
      assign
    
    
      OBJC_ASSOCIATION_RETAIN_NONATOMIC
      nonatomic, strong
    
    
      OBJC_ASSOCIATION_COPY_NONATOMIC
      nonatomic, copy
    
    
      OBJC_ASSOCIATION_RETAIN
      atomic, strong
    
    
      OBJC_ASSOCIATION_COPY
      atomic, copy
    
  


而我们在代码中实现的属性 categoryProperty 就相当于使用了 nonatomic 和 strong 修饰符。


  关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，Google 是一个很好的选择。


到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。

@property` 其实有元编程的思想，它能够为我们自动生成实例变量以及存取方法，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性：

self.property &amp;lt;=&amp;gt; [self property]
self.property = value &amp;lt;=&amp;gt; [self setProperty:value]


在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。


  如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。


关联对象的实现


  探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。


这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法：

void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
void objc_removeAssociatedObjects(id object);


三个方法的作用分别是：


  以键值对形式添加关联对象
  根据 key 获取关联对象
  移除所有关联对象


而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。

objc_setAssociatedObject

首先是 objc_setAssociatedObject 方法，这个方法的调用栈并不复杂：

void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 
└── void objc_setAssociatedObject_non_gc(id object, const void *key, id value, objc_AssociationPolicy policy)
    └── void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)


调用栈中的 _object_set_associative_reference 方法实际完成了设置关联对象的任务：

void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        ObjectAssociationMap *refs = i-&amp;gt;second;
        ...
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}



  在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。


我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用：


  AssociationsManager
  AssociationsHashMap
  ObjcAssociationMap
  ObjcAssociation


AssociationsManager

AssociationsManager 在源代码中的定义是这样的：

class AssociationsManager {
    static spinlock_t _lock;
    static AssociationsHashMap *_map;
public:
    AssociationsManager()   { _lock.lock(); }
    ~AssociationsManager()  { _lock.unlock(); }
    
    AssociationsHashMap &amp;amp;associations() {
        if (_map == NULL)
            _map = new AssociationsHashMap();
        return *_map;
    }
};

spinlock_t AssociationsManager::_lock;
AssociationsHashMap *AssociationsManager::_map = NULL;


它维护了 spinlock_t 和 AssociationsHashMap 的单例，初始化它的时候会调用 lock.lock() 方法，在析构时会调用 lock.unlock()，而 associations 方法用于取得一个全局的 AssociationsHashMap 单例。

也就是说 AssociationsManager 通过持有一个自旋锁 spinlock_t 保证对 AssociationsHashMap 的操作是线程安全的，即每次只会有一个线程对 AssociationsHashMap 进行操作。

如何存储 ObjcAssociation

ObjcAssociation 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。

首先，AssociationsHashMap 用与保存从对象的 disguised_ptr_t 到 ObjectAssociationMap 的映射：

class AssociationsHashMap : public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&amp;gt; {
public:
    void *operator new(size_t n) { return ::malloc(n); }
    void operator delete(void *ptr) { ::free(ptr); }
};


而 ObjectAssociationMap 则保存了从 key 到关联对象 ObjcAssociation 的映射，这个数据结构保存了当前对象对应的所有关联对象：

class ObjectAssociationMap : public std::map&amp;lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&amp;gt; {
public:
   void *operator new(size_t n) { return ::malloc(n); }
   void operator delete(void *ptr) { ::free(ptr); }
};


最关键的 ObjcAssociation 包含了 policy 以及 value：

class ObjcAssociation {
    uintptr_t _policy;
    id _value;
public:
    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}
    ObjcAssociation() : _policy(0), _value(nil) {}

    uintptr_t policy() const { return _policy; }
    id value() const { return _value; }
    
    bool hasValue() { return _value != nil; }
};


举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例：

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        NSObject *obj = [NSObject new];
        objc_setAssociatedObject(obj, @selector(hello), @&quot;Hello&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    }
    return 0;
}


这里的关联对象 ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @&quot;Hello&quot;) 在内存中是这么存储的：





接下来我们可以重新回到对 objc_setAssociatedObject 方法的分析了。

在这里会将方法的执行分为两种情况：


  new_value != nil 设置/更新关联对象的值
  new_value == nil 删除一个关联对象


new_value != nil

先来分析在 new_value != nil 的情况下，该方法的执行是什么样的：

void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&amp;gt;second;
            ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
            if (j != refs-&amp;gt;end()) {
                old_association = j-&amp;gt;second;
                j-&amp;gt;second = ObjcAssociation(policy, new_value);
            } else {
                (*refs)[key] = ObjcAssociation(policy, new_value);
            }
        } else {
            ObjectAssociationMap *refs = new ObjectAssociationMap;
            associations[disguised_object] = refs;
            (*refs)[key] = ObjcAssociation(policy, new_value);
            object-&amp;gt;setHasAssociatedObjects();
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}



  使用 old_association(0, nil) 创建一个临时的 ObjcAssociation 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）
  
    调用 acquireValue 对 new_value 进行 retain 或者 copy

     static id acquireValue(id value, uintptr_t policy) {
     switch (policy &amp;amp; 0xFF) {
     case OBJC_ASSOCIATION_SETTER_RETAIN:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
     case OBJC_ASSOCIATION_SETTER_COPY:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);
     }
     return value;
 }

  
  
    初始化一个 AssociationsManager，并获取唯一的保存关联对象的哈希表 AssociationsHashMap

     AssociationsManager manager;
 AssociationsHashMap &amp;amp;associations(manager.associations());

  
  先使用 DISGUISE(object) 作为 key 寻找对应的 ObjectAssociationMap
  
    如果没有找到，初始化一个 ObjectAssociationMap，再实例化 ObjcAssociation 对象添加到 Map 中，并调用 setHasAssociatedObjects 方法，表明当前对象含有关联对象

     ObjectAssociationMap *refs = new ObjectAssociationMap;
 associations[disguised_object] = refs;
 (*refs)[key] = ObjcAssociation(policy, new_value);
 object-&amp;gt;setHasAssociatedObjects();

  
  
    如果找到了对应的 ObjectAssociationMap，就要看 key 是否存在了，由此来决定是更新原有的关联对象，还是增加一个

     ObjectAssociationMap *refs = i-&amp;gt;second;
 ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
 if (j != refs-&amp;gt;end()) {
     old_association = j-&amp;gt;second;
     j-&amp;gt;second = ObjcAssociation(policy, new_value);
 } else {
     (*refs)[key] = ObjcAssociation(policy, new_value);
 }

  
  
    最后的最后，如果原来的关联对象有值的话，会调用 ReleaseValue() 释放关联对象的值

     struct ReleaseValue {
     void operator() (ObjcAssociation &amp;amp;association) {
         releaseValue(association.value(), association.policy());
     }
 };
    
 static void releaseValue(id value, uintptr_t policy) {
     if (policy &amp;amp; OBJC_ASSOCIATION_SETTER_RETAIN) {
         ((id(*)(id, SEL))objc_msgSend)(value, SEL_release);
     }
 }

  


到这里，该条件下的方法实现就结束了。

new_value == nil

如果 new_value == nil，就说明我们要删除对应 key 的关联对象，实现如下：

void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i !=  associations.end()) {
            ObjectAssociationMap *refs = i-&amp;gt;second;
            ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
            if (j != refs-&amp;gt;end()) {
                old_association = j-&amp;gt;second;
                refs-&amp;gt;erase(j);
            }
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}


这种情况下方法的实现与前面的唯一区别就是，我们会调用 erase 方法，擦除 ObjectAssociationMap 中 key 对应的节点。

setHasAssociatedObjects()

其实上面的两种情况已经将 objc_setAssociatedObject 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，setHasAssociatedObjects() 方法的作用是什么？

inline void objc_object::setHasAssociatedObjects() {
    if (isTaggedPointer()) return;

 retry:
    isa_t oldisa = LoadExclusive(&amp;amp;isa.bits);
    isa_t newisa = oldisa;
    if (!newisa.indexed) return;
    if (newisa.has_assoc) return;
    newisa.has_assoc = true;
    if (!StoreExclusive(&amp;amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;
}


它会将 isa 结构体中的标记位 has_assoc 标记为 true，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 isa 中的各个标记位都是干什么的。




  如果想要了解关于 isa 的知识，可以阅读从 NSObject 的初始化了解 isa


objc_getAssociatedObject

我们既然已经对 objc_setAssociatedObject 的实现已经比较熟悉了，相信对于 objc_getAssociatedObject 的理解也会更加容易。

方法的调用栈和 objc_setAssociatedObject 非常相似：

id objc_getAssociatedObject(id object, const void *key)
└── id objc_getAssociatedObject_non_gc(id object, const void *key);
    └── id _object_get_associative_reference(id object, void *key) 


而 _object_get_associative_reference 相比于前面方法的实现更加简单。

id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&amp;gt;second;
            ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
            if (j != refs-&amp;gt;end()) {
                ObjcAssociation &amp;amp;entry = j-&amp;gt;second;
                value = entry.value();
                policy = entry.policy();
                if (policy &amp;amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
            }
        }
    }
    if (value &amp;amp;&amp;amp; (policy &amp;amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
    }
    return value;
}


代码中寻找关联对象的逻辑和 objc_setAssociatedObject 差不多：


  获取静态变量 AssociationsHashMap
  以 DISGUISE(object) 为 key 查找 AssociationsHashMap
  以 void *key 为 key 查找 ObjcAssociation
  
    根据 policy 调用相应的方法

     if (policy &amp;amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
    
 if (value &amp;amp;&amp;amp; (policy &amp;amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
     ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
 }

  
  返回关联对象 ObjcAssociation 的值


objc_removeAssociatedObjects

关于最后的 objc_removeAssociatedObjects 方法，其实现也相对简单，这是方法的调用栈：

void objc_removeAssociatedObjects(id object)
└── void _object_remove_assocations(id object)


这是简化版本的 objc_removeAssociatedObjects 方法实现：

void objc_removeAssociatedObjects(id object) {
    if (object &amp;amp;&amp;amp; object-&amp;gt;hasAssociatedObjects()) {
        _object_remove_assocations(object);
    }
}


为了加速移除对象的关联对象的速度，我们会通过标记位 has_assoc 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 _object_remove_assocations 方法移除对象上所有的关联对象：

void _object_remove_assocations(id object) {
    vector&amp;lt; ObjcAssociation,ObjcAllocator&amp;lt;ObjcAssociation&amp;gt; &amp;gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        if (associations.size() == 0) return;
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&amp;gt;second;
            for (ObjectAssociationMap::iterator j = refs-&amp;gt;begin(), end = refs-&amp;gt;end(); j != end; ++j) {
                elements.push_back(j-&amp;gt;second);
            }
            delete refs;
            associations.erase(i);
        }
    }
    for_each(elements.begin(), elements.end(), ReleaseValue());
}


方法会将对象包含的所有关联对象加入到一个 vector 中，然后对所有的 ObjcAssociation 对象调用 ReleaseValue() 方法，释放不再被需要的值。

小结

关于应用

本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。


  如果你把属性理解为通过方法访问的实例变量，我相信这个问题的答案是不能，因为分类不能为类增加额外的实例变量。
  不过如果属性只是一个存取方法以及存储值的容器的集合，那么分类是可以实现属性的。



  分类中对属性的实现其实只是实现了一个看起来像属性的接口而已。


关于实现

关联对象又是如何实现并且管理的呢：


  关联对象其实就是 ObjcAssociation 对象
  关联对象由 AssociationsManager 管理并在  AssociationsHashMap 存储
  对象的指针以及其对应 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中
  ObjectAssociationMap 则是用于存储关联对象的数据结构
  每一个对象都有一个标记位 has_assoc 指示对象是否含有关联对象



  Follow: Draveness · Github


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Runtime的简单使用</title>
      <url>/ios/2017/02/23/Runtime%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="text">
  运行时获取类的properties
  运行时获取类的ivars
  运行获取类的instance methods
  运行时获取类的 class methods


运行时获取类的properties

//获取类的属性  
 
- (void)getPropertyList {   

//属性个数   
unsigned int count;    

objc_property_t *properties = class_copyPropertyList([self class], &amp;amp;count);   

for (int i = 0; i &amp;lt; count; i++) {   

    objc_property_t property = properties[i];   

    const char *name = property_getName(property);   

    NSString *nameStr = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];   

    NSLog(@&quot;***属性名:%@&quot;, nameStr);   

}     
}



此种方法只能获取类的属性,像:

@interface HomeController (){   
	int index;   
	NSString *name1;   
}    这种方法声明的&quot;index&quot;和&quot;name1&quot;属性是无法获取到的,如果获取该种属性则可使用class_copyIvarList()方法来获取.



运行时获取类的ivars

运行时获取类ivars
这里给出一个类:

@interface HomeController (){   



   	 	int index; 

	NSString *name1;   

}   

@property (nonatomic, strong) UILabel *msgLbl;   
@end    如果要获取&quot;index&quot;,&quot;name1&quot;,&quot;msgLbl&quot;这三个名字呢,有一个函数可以办到class_copyIvarList(),详细使用见工程.



运行获取类的instance methods

IOS中每一个类都有一个方法列表,用来保存类的实例方法,实例方法第一次调用完之后,会进行缓存方便下次调用.获取类的实例方法可以用class_copyMethodList()来获取.

运行时获取类的 class methods

每一个类都有一个方法列表保存该类的所有实例方法和其对应的实现,但一个类的类方法则不在这个方法列表中.那么一个类的类方法保存在那里呢?如果通过运行时的一些特性获取这些类方法呢?
在IOS开发中每一个类其实也是一个对象,既然IOS中每一个类是一个对象,那么它是什么什么类的对象呢?IOS中有一个元类的概念,即每一个类都有一个元类,通过isa指针指向自己的元类;元类也可以继承,NSObject类也有自己的元类,并且NSObject类的元类的isa指针指向它本身(NSObject类的元类).类方法不同于类的实例方法,类方法保存在一个类的元类中,那么如何获取一个类的元类呢?有两种方法:

1. const char * class_name = class_getName([self class]);  
   Class metaClass = objc_getMetaClass(class_name);
2. Class metaClass = object_getClass([self class]);    在获取到一个类的元类之后,我们就可以通过class_copyMethodList()来获取一个类的类方法.


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>『可变』的热信号 RACSubject</title>
      <url>/ios/2017/02/22/ReactiveCocoa-RACSubject/</url>
      <content type="text">在 ReactiveCocoa 中除了不可变的信号 RACSignal，也有用于桥接非 RAC 代码到 ReactiveCocoa 世界的『可变』信号 RACSubject。



RACSubject 到底是什么？根据其字面意思，可以将它理解为一个可以订阅的主题，我们在订阅主题之后，向主题发送新的消息时，所有的订阅者都会接收到最新的消息。

但是这么解释确实有点晦涩，也不易于理解，ReactiveCocoa 团队对 RACSubject 的解释是，RACSubject 其实就是一个可以手动控制的信号（感觉这么解释更难理解了）。


  A subject, represented by the RACSubject class, is a signal that can be manually controlled.


RACSubject 简介

RACSubject 是 RACSignal 的子类，与 RACSignal 以及 RACSequence 有着众多的类簇不同，RACSubject 在整个工程中并没有多少子类；不过，在大多数情况下，我们也只会使用 RACSubject 自己或者 RACReplaySubject。



相比于 RACSignal 丰富的头文件 ，RACSubject 对外的接口并没有提供太多的方法：

@interface RACSubject : RACSignal &amp;lt;RACSubscriber&amp;gt;

+ (instancetype)subject;

@end


唯一提供的接口就是用于返回一个新实例的 +subject 方法；除此之外，在笔者看来它与 RACSignal 最大的不同就是：RACSubject 实现了 RACSubscriber 协议，也就是下面的这些方法：

@protocol RACSubscriber &amp;lt;NSObject&amp;gt;
@required

- (void)sendNext:(nullable id)value;
- (void)sendError:(nullable NSError *)error;
- (void)sendCompleted;
- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;

@end


我们并不能在一个 RACSignal 对象上执行这些方法，只能在创建信号的 block 里面向遵循 RACSubscriber 协议的对象发送新的值或者错误，这也是 RACSubject 和父类最大的不同：在 RACSubject 实例初始化之后，也可以通过这个实例向所有的订阅者发送消息。

冷信号与热信号

提到 RACSubject 就不得不提 ReactiveCocoa 中的另一对概念，冷信号和热信号。


  其实解释这两者之间区别的文章已经很多了，我相信各位读者能找到很多的资料，在这里就简单介绍一下冷热信号的概念，如果想要了解更多的内容可以在 References 中找到更多的文章。


对于冷热信号概念，我们借用 Rx 中的描述：




  Cold signal is sequences that are passive and start producing notifications on request (when subscribed to), and hot signal is sequences that are active and produce notifications regardless of subscriptions. —- Hot and Cold observables


冷信号是被动的，只会在被订阅时向订阅者发送通知；热信号是主动的，它会在任意时间发出通知，与订阅者的订阅时间无关。

也就是说冷信号所有的订阅者会在订阅时收到完全相同的序列；而订阅热信号之后，只会收到在订阅之后发出的序列。


  热信号的订阅者能否收到消息取决于订阅的时间。


热信号在我们生活中有很多的例子，比如订阅杂志时并不会把之前所有的期刊都送到我们手中，只会接收到订阅之后的期刊；而对于冷信号的话，举一个不恰当的例子，每一年的高考考生在『订阅』高考之后，收到往年所有的试卷，并在高考之后会取消订阅。

热信号 RACSubject

在 ReactiveCocoa 中，我们使用 RACSignal 来表示冷信号，也就是每一个订阅者在订阅信号时都会收到完整的序列；RACSubject 用于表示热信号，订阅者接收到多少值取决于它订阅的时间。

前面的文章中已经对 RACSignal 冷信号有了很多的介绍，这里也就不会多说了；这一小节主要的内容是想通过一个例子，简单展示 RACSubject 的订阅者收到的内容与订阅时间的关系：

RACSubject *subject = [RACSubject subject];

// Subscriber 1
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;1st Sub: %@&quot;, x);
}];
[subject sendNext:@1];

// Subscriber 2
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;2nd Sub: %@&quot;, x);
}];
[subject sendNext:@2];

// Subscriber 3
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;3rd Sub: %@&quot;, x);
}];
[subject sendNext:@3];
[subject sendCompleted];


这里以图的方式来展示整个订阅与订阅者接收消息的过程：



从图中我们可以清楚的看到，几个订阅者根据订阅时间的不同收到了不同的数字序列，RACSubject 是时间相关的，它在发送消息时只会向已订阅的订阅者推送消息。

RACSubject 的实现

RACSubject 的实现并不复杂，它『可变』的特性都来源于持有的订阅者数组 subscribers，在每次执行 subscribeNext:error:completed: 一类便利方法时，都会将传入的 id&amp;lt;RACSubscriber&amp;gt; 对象加入数组：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];

	NSMutableArray *subscribers = self.subscribers;
	@synchronized (subscribers) {
		[subscribers addObject:subscriber];
	}

	[disposable addDisposable:[RACDisposable disposableWithBlock:^{
		@synchronized (subscribers) {
			NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&amp;lt;RACSubscriber&amp;gt; obj, NSUInteger index, BOOL *stop) {
				return obj == subscriber;
			}];

			if (index != NSNotFound) [subscribers removeObjectAtIndex:index];
		}
	}]];

	return disposable;
}


订阅的过程分为三个部分：


  初始化一个 RACPassthroughSubscriber 实例；
  将 subscriber 加入 RACSubject 持有的数组中；
  创建一个 RACDisposable 对象，在当前 subscriber 销毁时，将自身从数组中移除。




-subscribe: 将所有遵循 RACSubscriber 协议的对象全部加入当前 RACSubject 持有的数组 subscribers 中。

在上一节的例子中，我们能对 RACSubject 发送 -sendNext: 等消息也都取决于它实现了 RACSubscriber 协议：

- (void)sendNext:(id)value {
	[self enumerateSubscribersUsingBlock:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		[subscriber sendNext:value];
	}];
}

- (void)sendError:(NSError *)error {
	[self.disposable dispose];

	[self enumerateSubscribersUsingBlock:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		[subscriber sendError:error];
	}];
}

- (void)sendCompleted {
	[self.disposable dispose];

	[self enumerateSubscribersUsingBlock:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		[subscriber sendCompleted];
	}];
}


RACSubject 会在自身接受到这些方法时，下发给持有的全部的 subscribers。



代码中的 -enumerateSubscribersUsingBlock: 只是一个使用 for 循环遍历 subscribers 的安全方法：

- (void)enumerateSubscribersUsingBlock:(void (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))block {
	NSArray *subscribers;
	@synchronized (self.subscribers) {
		subscribers = [self.subscribers copy];
	}

	for (id&amp;lt;RACSubscriber&amp;gt; subscriber in subscribers) {
		block(subscriber);
	}
}


RACSubject 就是围绕一个 NSMutableArray 数组实现的，实现还是非常简单的，只是在需要访问 subscribers 的方法中使用 @synchronized 避免线程竞争。

@interface RACSubject ()

@property (nonatomic, strong, readonly) NSMutableArray *subscribers;

@end


RACSubject 提供的初始化类方法 +subject 也只是初始化了几个成员变量：

+ (instancetype)subject {
	return [[self alloc] init];
}

- (instancetype)init {
	self = [super init];
	if (self == nil) return nil;

	_disposable = [RACCompoundDisposable compoundDisposable];
	_subscribers = [[NSMutableArray alloc] initWithCapacity:1];

	return self;
}


至此，对于 RACSubject 的分析就结束了，接下来会分析更多的子类。

RACBehaviorSubject 与 RACReplaySubject

这一节会介绍 RACSubject 的两个子类 RACBehaviorSubject 和 RACReplaySubject，前者在订阅时会向订阅者发送最新的消息，后者在订阅之后可以重新发送之前的所有消息序列。

RACBehaviorSubject

先来介绍两者中实现较简单的 RACBehaviorSubject，它在内部会保存一个 currentValue 对象，也就是最后一次发送的消息：

@interface RACBehaviorSubject ()

@property (nonatomic, strong) id currentValue;

@end


在每次执行 -sendNext: 时，都会对 RACBehaviorSubject 中保存的 currentValue 进行更新，并使用父类的 -sendNext: 方法，向所有的订阅者发送最新的消息：

- (void)sendNext:(id)value {
	@synchronized (self) {
		self.currentValue = value;
		[super sendNext:value];
	}
}


RACBehaviorSubject 最重要的特性就是在订阅时，向最新的订阅者发送之前的消息，这是通过覆写 -subscribe: 方法实现的。

在调用子类的 -subscribe: 方法之后，会在 subscriber 对象上执行 -sendNext: 方法：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	RACDisposable *subscriptionDisposable = [super subscribe:subscriber];

	RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
		@synchronized (self) {
			[subscriber sendNext:self.currentValue];
		}
	}];

	return [RACDisposable disposableWithBlock:^{
		[subscriptionDisposable dispose];
		[schedulingDisposable dispose];
	}];
}


接下来，通过一个简单的例子来演示 RACBehaviorSubject 到底是如何工作的：

RACBehaviorSubject *subject = [RACBehaviorSubject subject];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;1st Sub: %@&quot;, x);
}];
[subject sendNext:@1];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;2nd Sub: %@&quot;, x);
}];
[subject sendNext:@2];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;3rd Sub: %@&quot;, x);
}];
[subject sendNext:@3];
[subject sendCompleted];


上面的代码其实与 RACSubject 一节中的代码差不多，只将 RACSubject 转换成了 RACBehaviorSubject 对象。



在每次订阅者订阅 RACBehaviorSubject 之后，都会向该订阅者发送最新的消息，这也就是 RACBehaviorSubject 最重要的行为。

RACBehaviorSubject 有一个用于创建包含默认值的类方法 +behaviorSubjectWithDefaultValue:，如果将上面的第一行代码改成：

RACBehaviorSubject *subject = [RACBehaviorSubject behaviorSubjectWithDefaultValue:@0];


那么在第一个订阅者刚订阅 RACBehaviorSubject 时就会收到 @0 对象。



RACReplaySubject

RACReplaySubject 相当于一个自带 buffer 的 RACBehaviorSubject，它可以在每次有新的订阅者订阅之后发送之前的全部消息。

@interface RACReplaySubject ()

@property (nonatomic, assign, readonly) NSUInteger capacity;
@property (nonatomic, strong, readonly) NSMutableArray *valuesReceived;

@end


实现的方式是通过持有一个 valuesReceived 的数组和能够存储的对象的上限 capacity，默认值为：

const NSUInteger RACReplaySubjectUnlimitedCapacity = NSUIntegerMax;


当然你可以用 +replaySubjectWithCapacity: 初始化一个其它大小的 RACReplaySubject 对象：

+ (instancetype)replaySubjectWithCapacity:(NSUInteger)capacity {
	return [(RACReplaySubject *)[self alloc] initWithCapacity:capacity];
}

- (instancetype)initWithCapacity:(NSUInteger)capacity {
	self = [super init];

	_capacity = capacity;
	_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);

	return self;
}


在每次调用 -sendNext: 方法发送消息时，都会将其加入 valuesReceived 数组中，并踢出之前的元素：

- (void)sendNext:(id)value {
	@synchronized (self) {
		[self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];
		[super sendNext:value];

		if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;amp;&amp;amp; self.valuesReceived.count &amp;gt; self.capacity) {
			[self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];
		}
	}
}


需要注意的有两点，一是对 valuesReceived 的数组的操作必须使用 @synchronized 加锁；第二，如果 value 为空的话，也需要将其转换成 RACTupleNil.tupleNil 对象进行保存。



-sendError: 和 -sendCompleted 方法都会标记对应 flag，即 hasCompleted 和 hasError，这里就不介绍了；同样的，RACReplaySubject 也覆写了 -subscribe: 方法，在每次有订阅者订阅时重新发送所有的序列：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

	RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
		@synchronized (self) {
			for (id value in self.valuesReceived) {
				if (compoundDisposable.disposed) return;

				[subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];
			}

			if (compoundDisposable.disposed) return;

			if (self.hasCompleted) {
				[subscriber sendCompleted];
			} else if (self.hasError) {
				[subscriber sendError:self.error];
			} else {
				RACDisposable *subscriptionDisposable = [super subscribe:subscriber];
				[compoundDisposable addDisposable:subscriptionDisposable];
			}
		}
	}];

	[compoundDisposable addDisposable:schedulingDisposable];

	return compoundDisposable;
}


我们仍然使用上一节中的例子来展示 RACReplaySubject 是如何工作的，只修改第一行代码：

RACReplaySubject *subject = [RACReplaySubject subject];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;1st Subscriber: %@&quot;, x);
}];
[subject sendNext:@1];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;2nd Subscriber: %@&quot;, x);
}];
[subject sendNext:@2];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;3rd Subscriber: %@&quot;, x);
}];
[subject sendNext:@3];
[subject sendCompleted];


运行这段代码之后，会得到如下图的结果：



所有订阅 RACReplaySubject 的对象（默认行为）都能获得完整的序列，而这个特性在与 RACMulticastConnection 一起使用也有着巨大威力，我们会在之后的文章中介绍。

总结

RACSubject 在 RACSignal 对象之上进行了简单的修改，将原有的冷信号改造成了热信号，将不可变变成了可变。

虽然 RACSubject 的实现并不复杂，只是存储了一个遵循 RACSubscriber 协议的对象列表以及所有的消息，但是在解决实际问题时却能够很好地解决很多与网络操作相关的问题。

References


  细说 ReactiveCocoa 的冷信号与热信号
  Hot and Cold observables



  Github Repo：iOS-Source-Code-Analyze

  Follow: Draveness · GitHub

  Source: http://draveness.me/racsubject

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>从源代码看 ObjC 中消息的发送</title>
      <url>/ios/2017/02/17/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B-ObjC-%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81/</url>
      <content type="text">
  因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。


写在前面

如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：


  在 Objective-C 中的“方法调用”其实应该叫做消息传递
  [receiver message] 会被翻译为 objc_msgSend(receiver, @selector(message))
  在消息的响应链中可能会调用 - resolveInstanceMethod: - forwardInvocation: 等方法
  
    关于选择子 SEL 的知识

    
      如果对于上述的知识不够了解，可以看一下这篇文章 Objective-C Runtime，但是其中关于 objc_class 的结构体的代码已经过时了，不过不影响阅读以及理解。
    
  
  
    方法在内存中存储的位置，深入解析 ObjC 中方法的结构（可选）

    
      文章中不会刻意区别方法和函数、消息传递和方法调用之间的区别。
    
  
  能翻墙（会有一个 Youtube 的链接）


概述

关于 Objective-C 中的消息传递的文章真的是太多了，而这篇文章又与其它文章有什么不同呢？

由于这个系列的文章都是对 Objective-C 源代码的分析，所以会从 Objective-C 源代码中分析并合理地推测一些关于消息传递的问题。


![objc-message-core](../images/objc-message-core.png)

## 关于 @selector() 你需要知道的

因为在 Objective-C 中，所有的消息传递中的“消息“都会被转换成一个 `selector` 作为 `objc_msgSend` 函数的参数：

```objectivec
[object hello] -&amp;gt; objc_msgSend(object, @selector(hello))
```

这里面使用 `@selector(hello)` 生成的选择子 **SEL** 是这一节中关注的重点。

我们需要预先解决的问题是：使用 `@selector(hello)` 生成的选择子，是否会因为类的不同而不同？各位读者可以自己思考一下。

先放出结论：使用 `@selector()` 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说**向不同的类发送相同的消息时，其生成的选择子是完全相同的**。

```objectivec
XXObject *xx = [[XXObject alloc] init]
YYObject *yy = [[YYObject alloc] init]
objc_msgSend(xx, @selector(hello))
objc_msgSend(yy, @selector(hello))
```

接下来，我们开始验证这一结论的正确性，这是程序主要包含的代码：

```objectivec
// XXObject.h
#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import &quot;XXObject.h&quot;

@implementation XXObject

- (void)hello {
    NSLog(@&quot;Hello&quot;);
}

@end
// main.m
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;XXObject.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
```

在主函数任意位置打一个断点， 比如 `-&amp;gt; [object hello];` 这里，然后在 lldb 中输入：


![objc-message-selecto](../images/objc-message-selector.png)

这里面我们打印了两个选择子的地址` @selector(hello)` 以及 `@selector(undefined_hello_method)`，需要注意的是：

&amp;gt; `@selector(hello)` 是在编译期间就声明的选择子，而后者在编译期间并不存在，`undefined_hello_method` 选择子由于是在运行时生成的，所以内存地址明显比 `hello` 大很多

如果我们修改程序的代码：


![objc-message-selector-undefined](../images/objc-message-selector-undefined.png)

在这里，由于我们在代码中显示地写出了 `@selector(undefined_hello_method)`，所以在 lldb 中再次打印这个 `sel` 内存地址跟之前相比有了很大的改变。

更重要的是，我没有通过指针的操作来获取 `hello` 选择子的内存地址，而只是通过 `@selector(hello)` 就可以返回一个选择子。

从上面的这些现象，可以推断出选择子有以下的特性：

1. Objective-C 为我们维护了一个巨大的选择子表
2. 在使用 `@selector()` 时会从这个选择子表中根据选择子的名字查找对应的 `SEL`。如果没有找到，则会生成一个 `SEL` 并添加到表中
3. 在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 `@selector()` 生成的选择子加入到选择子表中

在运行时初始化之前，打印 `hello` 选择子的的内存地址：


![objc-message-find-selector-before-init](../images/objc-message-find-selector-before-init.png)

## message.h 文件

Objective-C 中 `objc_msgSend` 的实现并没有开源，它只存在于 `message.h` 这个头文件中。

```objectivec
/** 
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; 
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 */
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
```

在这个头文件的注释中对**消息发送的一系列方法**解释得非常清楚：

&amp;gt; 当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 `objc_msgSend`、`objc_msgSend_stret`、`objc_msgSendSuper` 和 `objc_msgSendSuper_stret`。
&amp;gt; 发送给对象的父类的消息会使用 `objc_msgSendSuper`
&amp;gt; 有数据结构作为返回值的方法会使用 `objc_msgSendSuper_stret` 或 `objc_msgSend_stret`
&amp;gt; 其它的消息都是使用 `objc_msgSend` 发送的

在这篇文章中，我们只会对**消息发送的过程**进行分析，而不会对**上述消息发送方法的区别**进行分析，默认都使用 `objc_msgSend` 函数。

## objc_msgSend 调用栈

这一小节会以向 `XXObject` 的实例发送 `hello` 消息为例，在 Xcode 中观察整个消息发送的过程中调用栈的变化，再来看一下程序的代码：

```objectivec
// XXObject.h
#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import &quot;XXObject.h&quot;

@implementation XXObject

- (void)hello {
    NSLog(@&quot;Hello&quot;);
}

@end
// main.m
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;XXObject.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
```

在调用 `hello` 方法的这一行打一个断点，当我们尝试进入（Step in）这个方法只会直接跳入这个方法的实现，而不会进入 `objc_msgSend`：


![objc-message-wrong-step-in](../images/objc-message-wrong-step-in.gif)

因为 `objc_msgSend` 是一个私有方法，我们没有办法进入它的实现，但是，我们却可以在 `objc_msgSend` 的调用栈中“截下”这个函数调用的过程。

调用 `objc_msgSend` 时，传入了 `self` 以及 `SEL` 参数。

既然要执行对应的方法，肯定要寻找选择子对应的实现。

在 `objc-runtime-new.mm` 文件中有一个函数 `lookUpImpOrForward`，这个函数的作用就是查找方法的实现，于是运行程序，在运行到 `hello` 这一行时，激活 `lookUpImpOrForward` 函数中的断点。




&amp;gt; 由于转成 gif 实在是太大了，笔者试着用各种方法生成动图，然而效果也不是很理想，只能贴一个 Youtube 的视频链接，不过对于能够翻墙的开发者们，应该也不是什么问题吧（手动微笑）

如果跟着视频看这个方法的调用栈有些混乱的话，也是正常的。在下一个节中会对其调用栈进行详细的分析。

# 解析 objc_msgSend

对 `objc_msgSend` 解析总共分两个步骤，我们会向 `XXObject` 的实例发送两次 `hello` 消息，分别模拟无缓存和有缓存两种情况下的调用栈。

## 无缓存

在 `-&amp;gt; [object hello]` 这里增加一个断点，**当程序运行到这一行时**，再向 `lookUpImpOrForward` 函数的第一行添加断点，确保是捕获 `@selector(hello)` 的调用栈，而不是调用其它选择子的调用栈。


![objc-message-first-call-hello](../images/objc-message-first-call-hello.png)

由图中的变量区域可以了解，传入的选择子为 `&quot;hello&quot;`，对应的类是 `XXObject`。所以我们可以确信这就是当调用 `hello` 方法时执行的函数。在 Xcode 左侧能看到方法的调用栈：

```objectivec
0 lookUpImpOrForward
1 _class_lookupMethodAndLoadCache3
2 objc_msgSend
3 main
4 start
```

调用栈在这里告诉我们： `lookUpImpOrForward` 并不是 `objc_msgSend` 直接调用的，而是通过 `_class_lookupMethodAndLoadCache3` 方法：

```objectivec
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
```

这是一个**仅提供给派发器（dispatcher）**用于方法查找的函数，其它的代码都应该使用 `lookUpImpOrNil()`（不会进行方法转发）。`_class_lookupMethodAndLoadCache3` 会传入 `cache = NO` 避免在**没有加锁**的时候对缓存进行查找，因为派发器已经做过这件事情了。

### 实现的查找 lookUpImpOrForward

由于实现的查找方法 `lookUpImpOrForward` 涉及很多函数的调用，所以我们将它分成以下几个部分来分析：

1. 无锁的缓存查找
2. 如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类
3. 加锁
4. 缓存以及当前类中方法的查找
5. 尝试查找父类的缓存以及方法列表
6. 没有找到实现，尝试方法解析器
7. 进行消息转发
8. 解锁、返回实现

#### 无锁的缓存查找

下面是在没有加锁的时候对缓存进行查找，提高缓存使用的性能：

```objectivec
runtimeLock.assertUnlocked();

// Optimistic cache lookup
if (cache) {
   imp = cache_getImp(cls, sel);
   if (imp) return imp;
}
```

不过因为 `_class_lookupMethodAndLoadCache3` 传入的 `cache = NO`，所以这里会直接跳过 if 中代码的执行，在 `objc_msgSend` 中已经使用汇编代码查找过了。

#### 类的实现和初始化

在 *Objective-C 运行时* 初始化的过程中会对其中的类进行第一次初始化也就是执行 `realizeClass` 方法，为类分配可读写结构体 `class_rw_t` 的空间，并返回正确的类结构体。

而 `_class_initialize` 方法会调用类的 `initialize` 方法，我会在之后的文章中对类的初始化进行分析。

```objectivec
if (!cls-&amp;gt;isRealized()) {
    rwlock_writer_t lock(runtimeLock);
    realizeClass(cls);
}

if (initialize  &amp;amp;&amp;amp;  !cls-&amp;gt;isInitialized()) {
    _class_initialize (_class_getNonMetaClass(cls, inst));
}
```

#### 加锁

加锁这一部分只有一行简单的代码，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有**新方法添加导致缓存被冲洗（flush）**。

```objectivec
runtimeLock.read();
```

#### 在当前类中查找实现

实现很简单，先调用了 `cache_getImp` 从某个类的 `cache` 属性中获取选择子对应的实现：

```objectivec
imp = cache_getImp(cls, sel);
if (imp) goto done;
```


![objc-message-cache-struct](../images/objc-message-cache-struct.png)

不过 `cache_getImp` 的实现目测是不开源的，同时也是汇编写的，在我们尝试 step in 的时候进入了如下的汇编代码。


![objc-message-step-in-cache-getimp](../images/objc-message-step-in-cache-getimp.png)

它会进入一个 `CacheLookup` 的标签，获取实现，使用汇编的原因还是因为要加速整个实现查找的过程，其原理推测是在类的 `cache` 中寻找对应的实现，只是做了一些性能上的优化。

如果查找到实现，就会跳转到 `done` 标签，因为我们在这个小结中的假设是无缓存的（第一次调用 `hello` 方法），所以会进入下面的代码块，从类的方法列表中寻找方法的实现：

```objectivec
meth = getMethodNoSuper_nolock(cls, sel);
if (meth) {
    log_and_fill_cache(cls, meth-&amp;gt;imp, sel, inst, cls);
    imp = meth-&amp;gt;imp;
    goto done;
}
```

调用 `getMethodNoSuper_nolock` 方法查找对应的方法的结构体指针 `method_t`：

```objectivec
static method_t *getMethodNoSuper_nolock(Class cls, SEL sel) {
    for (auto mlists = cls-&amp;gt;data()-&amp;gt;methods.beginLists(), 
              end = cls-&amp;gt;data()-&amp;gt;methods.endLists(); 
         mlists != end;
         ++mlists)
    {
        method_t *m = search_method_list(*mlists, sel);
        if (m) return m;
    }

    return nil;
}
```

因为类中数据的方法列表 `methods` 是一个二维数组 `method_array_t`，写一个 `for` 循环遍历整个方法列表，而这个 `search_method_list` 的实现也特别简单：

```objectivec
static method_t *search_method_list(const method_list_t *mlist, SEL sel)
{
    int methodListIsFixedUp = mlist-&amp;gt;isFixedUp();
    int methodListHasExpectedSize = mlist-&amp;gt;entsize() == sizeof(method_t);
    
    if (__builtin_expect(methodListIsFixedUp &amp;amp;&amp;amp; methodListHasExpectedSize, 1)) {
        return findMethodInSortedMethodList(sel, mlist);
    } else {
        for (auto&amp;amp; meth : *mlist) {
            if (meth.name == sel) return &amp;meth;
        }
    }

    return nil;
}
```

`findMethodInSortedMethodList` 方法对有序方法列表进行线性探测，返回方法结构体 `method_t`。

如果在这里找到了方法的实现，将它加入类的缓存中，这个操作最后是由 `cache_fill_nolock` 方法来完成的：

```objectivec
static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)
{
    if (!cls-&amp;gt;isInitialized()) return;
    if (cache_getImp(cls, sel)) return;

    cache_t *cache = getCache(cls);
    cache_key_t key = getKey(sel);

    mask_t newOccupied = cache-&amp;gt;occupied() + 1;
    mask_t capacity = cache-&amp;gt;capacity();
    if (cache-&amp;gt;isConstantEmptyCache()) {
        cache-&amp;gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);
    } else if (newOccupied &amp;lt;= capacity / 4 * 3) {

    } else {
        cache-&amp;gt;expand();
    }

    bucket_t *bucket = cache-&amp;gt;find(key, receiver);
    if (bucket-&amp;gt;key() == 0) cache-&amp;gt;incrementOccupied();
    bucket-&amp;gt;set(key, imp);
}
```

如果缓存中的内容大于容量的 `3/4` 就会扩充缓存，使缓存的大小翻倍。

&amp;gt; 在缓存翻倍的过程中，当前类**全部的缓存都会被清空**，Objective-C 出于性能的考虑不会将原有缓存的 `bucket_t` 拷贝到新初始化的内存中。

找到第一个空的 `bucket_t`，以 `(SEL, IMP)` 的形式填充进去。

#### 在父类中寻找实现

这一部分与上面的实现基本上是一样的，只是多了一个循环用来判断根类：

1. 查找缓存
2. 搜索方法列表

```objectivec
curClass = cls;
while ((curClass = curClass-&amp;gt;superclass)) {
    imp = cache_getImp(curClass, sel);
    if (imp) {
        if (imp != (IMP)_objc_msgForward_impcache) {
            log_and_fill_cache(cls, imp, sel, inst, curClass);
            goto done;
        } else {
            break;
        }
    }

    meth = getMethodNoSuper_nolock(curClass, sel);
    if (meth) {
        log_and_fill_cache(cls, meth-&amp;gt;imp, sel, inst, curClass);
        imp = meth-&amp;gt;imp;
        goto done;
    }
}
```

与当前类寻找实现的区别是：在父类中寻找到的 `_objc_msgForward_impcache` 实现会交给当前类来处理。

#### 方法决议

选择子在当前类和父类中都没有找到实现，就进入了方法决议（method resolve）的过程：

```objectivec
if (resolver  &amp;amp;&amp;amp;  !triedResolver) {
    _class_resolveMethod(cls, sel, inst);
    triedResolver = YES;
    goto retry;
}
```

这部分代码调用 `_class_resolveMethod` 来解析没有找到实现的方法。

```objectivec
void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&amp;gt;isMetaClass()) {
        _class_resolveInstanceMethod(cls, sel, inst);
    } 
    else {
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst, 
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) 
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}
```

根据当前的类是不是[元类](http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html)在 `_class_resolveInstanceMethod` 和 `_class_resolveClassMethod` 中选择一个进行调用。

```objectivec
static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst) {
    if (! lookUpImpOrNil(cls-&amp;gt;ISA(), SEL_resolveInstanceMethod, cls, 
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) {
        // 没有找到 resolveInstanceMethod: 方法，直接返回。
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (__typeof__(msg))objc_msgSend;
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // 缓存结果，以防止下次在调用 resolveInstanceMethod: 方法影响性能。
    IMP imp = lookUpImpOrNil(cls, sel, inst, 
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);
}
```

这两个方法的实现其实就是判断当前类是否实现了 `resolveInstanceMethod:` 或者 `resolveClassMethod:` 方法，然后用 `objc_msgSend` 执行上述方法，并传入需要决议的选择子。

&amp;gt; 关于 `resolveInstanceMethod` 之后可能会写一篇文章专门介绍，不过关于这个方法的文章也确实不少，在 Google 上搜索会有很多的文章。

在执行了 `resolveInstanceMethod:` 之后，会跳转到 retry 标签，**重新执行查找方法实现的流程**，只不过不会再调用 `resolveInstanceMethod:` 方法了（将 `triedResolver` 标记为 `YES`）。

#### 消息转发

在缓存、当前类、父类以及 `resolveInstanceMethod:` 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发：

```objectivec
imp = (IMP)_objc_msgForward_impcache;
cache_fill(cls, sel, imp, inst);
```

返回实现 `_objc_msgForward_impcache`，然后加入缓存。

====

这样就结束了整个方法第一次的调用过程，缓存没有命中，但是在当前类的方法列表中找到了 `hello` 方法的实现，调用了该方法。


![objc-message-first-call-hello](../images/objc-message-first-call-hello.png)


## 缓存命中

如果使用对应的选择子时，缓存命中了，那么情况就大不相同了，我们修改主程序中的代码：

```objectivec
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
```

然后在第二次调用 `hello` 方法时，加一个断点：


![objc-message-objc-msgSend-with-cache](../images/objc-message-objc-msgSend-with-cache.gif)

`objc_msgSend` 并没有走 `lookupImpOrForward` 这个方法，而是直接结束，打印了另一个 `hello` 字符串。

我们如何确定 `objc_msgSend` 的实现到底是什么呢？其实我们没有办法来**确认**它的实现，因为这个函数的实现使用汇编写的，并且实现是不开源的。

不过，我们需要确定它是否真的**访问了类中的缓存**来加速实现寻找的过程。

好，现在重新运行程序至第二个 `hello` 方法调用之前：


![objc-message-before-flush-cache](../images/objc-message-before-flush-cache.png)

打印缓存中 bucket 的内容：

```objectivec
(lldb) p (objc_class *)[XXObject class]
(objc_class *) $0 = 0x0000000100001230
(lldb) p (cache_t *)0x0000000100001240
(cache_t *) $1 = 0x0000000100001240
(lldb) p *$1
(cache_t) $2 = {
  _buckets = 0x0000000100604bd0
  _mask = 3
  _occupied = 2
}
(lldb) p $2.capacity()
(mask_t) $3 = 4
(lldb) p $2.buckets()[0]
(bucket_t) $4 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[1]
(bucket_t) $5 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[2]
(bucket_t) $6 = {
  _key = 4294971294
  _imp = 0x0000000100000e60 (debug-objc`-[XXObject hello] at XXObject.m:17)
}
(lldb) p $2.buckets()[3]
(bucket_t) $7 = {
  _key = 4300169955
  _imp = 0x00000001000622e0 (libobjc.A.dylib`-[NSObject init] at NSObject.mm:2216)
}
```

在这个缓存中只有对 `hello` 和 `init` 方法实现的缓存，我们要将其中 `hello` 的缓存清空：

```objectivec
(lldb) expr $2.buckets()[2] = $2.buckets()[1]
(bucket_t) $8 = {
  _key = 0
  _imp = 0x0000000000000000
}
```


![objc-message-after-flush-cache](../images/objc-message-after-flush-cache.png)

这样 `XXObject` 中就不存在 `hello` 方法对应实现的缓存了。然后继续运行程序：


![objc-message-after-flush-cache-trap-in-lookup-again](../images/objc-message-after-flush-cache-trap-in-lookup-again.png)

虽然第二次调用 `hello` 方法，但是因为我们清除了 `hello` 的缓存，所以，会再次进入 `lookupImpOrForward` 方法。

下面会换一种方法验证猜测：**在 hello 调用之前添加缓存**。

添加一个新的实现 `cached_imp`：

```objectivec
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;objc/runtime.h&amp;gt;
#import &quot;XXObject.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __unused IMP cached_imp = imp_implementationWithBlock(^() {
            NSLog(@&quot;Cached Hello&quot;);
        });
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
```

我们将以 `@selector(hello), cached_imp` 为键值对，将其添加到类结构体的缓存中，这里的实现 `cached_imp` 有一些区别，它会打印 `@&quot;Cached Hello&quot;` 而不是 `@&quot;Hello&quot;` 字符串：

在第一个 `hello` 方法调用之前将实现加入缓存：


![objc-message-add-imp-to-cache](../images/objc-message-add-imp-to-cache.png)

然后继续运行代码：


![objc-message-run-after-add-cache](../images/objc-message-run-after-add-cache.png)

可以看到，我们虽然没有改变 `hello` 方法的实现，但是在 **objc_msgSend** 的消息发送链路中，使用错误的缓存实现 `cached_imp` 拦截了实现的查找，打印出了 `Cached Hello`。

由此可以推定，`objc_msgSend` 在实现中确实检查了缓存。如果没有缓存会调用 `lookupImpOrForward` 进行方法查找。

为了提高消息传递的效率，ObjC 对 `objc_msgSend` 以及  `cache_getImp` 使用了汇编语言来编写。

如果你想了解有关 `objc_msgSend` 方法的汇编实现的信息，可以看这篇文章 [Let's Build objc_msgSend](https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html)

## 小结

这篇文章与其说是讲 ObjC 中的消息发送的过程，不如说是讲方法的实现是如何查找的。

Objective-C 中实现查找的路径还是比较符合直觉的：
 
 1. 缓存命中
 2. 查找当前类的缓存及方法
 3. 查找父类的缓存及方法
 3. 方法决议
 4. 消息转发

文章中关于方法调用栈的视频最开始是用 gif 做的，不过由于 gif 时间较长，试了很多的 gif 转换器，都没有得到一个较好的质量和合适的大小，所以最后选择用一个 Youtube 的视频。

## 参考资料

+ [深入解析 ObjC 中方法的结构](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md)
+ [Objective-C Runtime](http://tech.glowing.com/cn/objective-c-runtime/)
+ [Let's Build objc_msgSend](https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html)

Follow: [@Draveness](https://github.com/Draveness)



</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>ReactiveCocoa--RACSignal</title>
      <url>/ios/2017/02/17/ReactiveCocoa-RACSignal/</url>
      <content type="text">

这篇以及之后的文章主要会对 ReactiveObjc v2.1.2 的实现进行分析，从最简单的例子中了解 ReactiveCocoa 的工作原理以及概念，也是笔者个人对于 RAC 学习的总结与理解。本文主要会围绕 RAC 中核心概念 RACSignal 展开，详细了解其底层实现。

状态驱动

2015 年的夏天的时候，做了几个简单的开源框架，想做点其它更有意思的框架却没什么思路，就开始看一些跟编程没有太大关系的书籍。

其中一本叫做《失控》给了我很大的启发，其中有一则故事是这样的：


  布鲁克斯开展了一个雄心勃勃的研究生课题项目，研发更接近昆虫而非恐龙的机器人。

  布鲁克斯的设想在一个叫「成吉思」的机巧装置上成形。成吉思有橄榄球大小，像只蟑螂似的。布鲁克斯把他的精简理念发挥到了极致。小成吉思有 6 条腿却没有一丁点儿可以称为「脑」的东西。所有 12 个电机和 21 个传感器分布在没有中央处理器的可解耦网络上。然而这 12 个充当肌肉的电机和 21 个传感器之间的交互作用居然产生了令人惊叹的复杂性和类似生命体的行为。

  成吉思的每条小细腿都在自顾自地工作，和其余的腿毫无关系。每条腿都通过自己的一组神经元——一个微型处理器——来控制其动作。每条腿只需管好自己！对成吉思来说，走路是一个团队合作项目，至少有六个小头脑在工作。它体内其余更微小的脑力则负责腿与腿之间的通讯。昆虫学家说这正是蚂蚁和蟑螂的解决之道——这些爬行昆虫的足肢上的神经元负责为该足肢进行思考。

  —— 《失控》第三章·第二节 快速、廉价、失控


书中对于机器人的介绍比较冗长，在这里就简单总结一下：机器人的每一条腿都单独进行工作，通过传感器感应的状态做出响应：


  如果腿抬起来了，那么它要落下去；
  如果腿在向前动，要让另外五条腿距离它远一点；


这种去中心化的方式，简化了整个系统的构造，使得各个组件只需要关心状态，以及状态对应的动作；不再需要一个中枢系统来组织、管理其它的组件，并负责大多数的业务逻辑。这种自底向下的、状态驱动的构建方式能够使用多个较小的组件，减少臃肿的中枢出现的可能性，从而降低系统的复杂度。

ReactiveCocoa 与信号

ReactiveCocoa 对于状态的理解与《失控》一书中十分类似，将原有的各种设计模式，包括代理、Target/Action、通知中心以及观察者模式各种『输入』，都抽象成了信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。

在 ReactiveCocoa 中最重要的信号，也就是 RACSignal 对象是这一篇文章介绍的核心；文章中主要会介绍下面的代码片段出现的内容：

RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@&quot;dispose&quot;);
    }];
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;%@&quot;, x);
}];


在上述代码执行时，会在控制台中打印出以下内容：

1
2
dispose



代码片段基本都是围绕 RACSignal 类进行的，文章会分四部分对上面的代码片段的工作流程进行简单的介绍：


  简单了解 RACSignal
  信号的创建
  信号的订阅与发送
  订阅的回收过程


RACSignal 简介

RACSignal 其实是抽象类 RACStream 的子类，在整个 ReactiveObjc 工程中有另一个类 RACSequence 也继承自抽象类 RACStream：



RACSignal 可以说是 ReactiveCocoa 中的核心类，也是最重要的概念，整个框架围绕着 RACSignal 的概念进行组织，对 RACSignal 最简单的理解就是它表示一连串的状态：



在状态改变时，对应的订阅者 RACSubscriber 就会收到通知执行相应的指令，在 ReactiveCocoa 的世界中所有的消息都是通过信号的方式来传递的，原有的设计模式都会简化为一种模型，这篇文章作为 ReactiveCocoa 系列的第一篇文章并不会对这些问题进行详细的展开和介绍，只会对 RACSignal 使用过程的原理进行简单的分析。

这一小节会对 RACStream 以及 RACSignal 中与 RACStream 相关的部分进行简单的介绍。

RACStream

RACStream 作为抽象类本身不提供方法的实现，其实现内部原生提供的而方法都是抽象方法，会在调用时直接抛出异常：

+ (__kindof RACStream *)empty {
	NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];
	@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
}

- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;
+ (__kindof RACStream *)return:(id)value;
- (__kindof RACStream *)concat:(RACStream *)stream;
- (__kindof RACStream *)zipWith:(RACStream *)stream;




上面的这些抽象方法都需要子类覆写，不过 RACStream 在 Operations 分类中使用上面的抽象方法提供了丰富的内容，比如说 -flattenMap: 方法：

- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
	Class class = self.class;

	return [[self bind:^{
		return ^(id value, BOOL *stop) {
			id stream = block(value) ?: [class empty];
			NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);

			return stream;
		};
	}] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];
}


其他方法比如 -skip:、-take:、-ignore： 等等实例方法都构建在这些抽象方法之上，只要子类覆写了所有抽象方法就能自动获得所有的 Operation 分类中的方法。



RACSignal 与 Monad


  如果你对 Monad 有所了解，那么你应该知道 bind 和 return 其实是 Monad 中的概念，但 Monad 并不是本篇文章所覆盖的内容，并不会具体解释它到底是什么。


ReactiveCocoa 框架中借鉴了很多其他平台甚至语言中的概念，包括微软中的 Reactive Extension 以及 Haskell 中的 Monad，RACStream 提供的抽象方法中的 +return: 和 -bind: 就与 Haskell 中 Monad 完全一样。


  很多人都说 Monad 只是一个自函子范畴上的一个幺半群而已；在笔者看来这种说法虽然是正确的，不过也很扯淡，这句话解释了还是跟没解释一样，如果有人再跟你用这句话解释 Monad，我觉得你最好的回应就是买一本范畴论糊他一脸。如果真的想了解 Haskell 中的 Monad 到底是什么？可以从代码的角度入手，多写一些代码就明白了，这个概念理解起来其实根本没什么困难的，当然也可以看一下 A Fistful of Monads，写写其中的代码，会对 Monad 有自己的认知，当然，请不要再写一篇解释 Monad 的教程了（手动微笑）。


首先来看一下 +return 方法的 实现：

+ (RACSignal *)return:(id)value {
	return [RACReturnSignal return:value];
}


该方法接受一个 NSObject 对象，并返回一个 RACSignal 的实例，它会将一个 UIKit 世界的对象 NSObject 转换成 ReactiveCocoa 中的 RACSignal：



而 RACReturnSignal 也仅仅是把 NSObject 对象包装一下，并没有做什么复杂的事情：

+ (RACSignal *)return:(id)value {
	RACReturnSignal *signal = [[self alloc] init];
	signal-&amp;gt;_value = value;
	return signal;
}


但是 -bind: 方法的 实现 相比之下就十分复杂了：

- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        return [self subscribeNext:^(id x) {
            BOOL stop = NO;
            id signal = bindingBlock(x, &amp;amp;stop);

            if (signal != nil) {
                [signal subscribeNext:^(id x) {
                    [subscriber sendNext:x];
                } error:^(NSError *error) {
                    [subscriber sendError:error];
                } completed:^{
                    [subscriber sendCompleted];
                }];
            }
            if (signal == nil || stop) {
                [subscriber sendCompleted];
            }
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            [subscriber sendCompleted];
        }];
    }] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];
}



  笔者在这里对 -bind: 方法进行了大量的省略，省去了其中对各种 RACDisposable 的处理过程。


-bind: 方法会在原信号每次发出消息时，都执行 RACSignalBindBlock 对原有的信号中的消息进行变换生成一个新的信号：




  在原有的 RACSignal 对象上调用 -bind: 方法传入 RACSignalBindBlock，图示中的右侧就是具体的执行过程，原信号在变换之后变成了新的蓝色的 RACSignal 对象。


RACSignalBindBlock 可以简单理解为一个接受 NSObject 对象返回 RACSignal 对象的函数：

typedef RACSignal * _Nullable (^RACSignalBindBlock)(id _Nullable value, BOOL *stop);


其函数签名可以理解为 id -&amp;gt; RACSignal，然而这种函数是无法直接对 RACSignal 对象进行变换的；不过通过 -bind: 方法就可以使用这种函数操作 RACSignal，其实现如下：


  将 RACSignal 对象『解包』出 NSObject 对象；
  将 NSObject 传入 RACSignalBindBlock 返回 RACSignal。


如果在不考虑 RACSignal 会发出错误或者完成信号时，-bind: 可以简化为更简单的形式：

- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        return [self subscribeNext:^(id x) {
            BOOL stop = NO;
            [bindingBlock(x, &amp;amp;stop) subscribeNext:^(id x) {
                [subscriber sendNext:x];
            }];
        }];
    }] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];
}


调用 -subscribeNext: 方法订阅当前信号，将信号中的状态解包，然后将原信号中的状态传入 bindingBlock 中并订阅返回的新的信号，将生成的新状态 x 传回原信号的订阅者。

这里通过两个简单的例子来了解 -bind: 方法的作用：

RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendNext:@4];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        value = @(value.integerValue * value.integerValue);
        return [RACSignal return:value];
    };
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;signal: %@&quot;, x);
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;bindSignal: %@&quot;, x);
}];


上面的代码中直接使用了 +return: 方法将 value 打包成了 RACSignal * 对象：




  在 BindSignal 中的每一个数字其实都是由一个 RACSignal 包裹的，这里没有画出，在下一个例子中，读者可以清晰地看到其中的区别。


上图简要展示了变化前后的信号中包含的状态，在运行上述代码时，会在终端中打印出：

signal: 1
signal: 2
signal: 3
signal: 4
bindSignal: 1
bindSignal: 4
bindSignal: 9
bindSignal: 16


这是一个最简单的例子，直接使用 -return: 打包 NSObject 返回一个 RACSignal，接下来用一个更复杂的例子来帮助我们更好的了解 -bind: 方法：

RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSNumber *returnValue = @(value.integerValue * value.integerValue);
        return [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
            for (NSInteger i = 0; i &amp;lt; value.integerValue; i++) [subscriber sendNext:returnValue];
            [subscriber sendCompleted];
            return nil;
        }];
    };
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;%@&quot;, x);
}];


下图相比上面例子中的图片更能精确的表现出 -bind: 方法都做了什么：



信号中原有的状态经过 -bind: 方法中传入 RACSignalBindBlock 的处理实际上返回了多个 RACSignal。

在源代码的注释中清楚地写出了方法的实现过程：


  订阅原信号中的值；
  将原信号发出的值传入 RACSignalBindBlock 进行转换；
  如果 RACSignalBindBlock 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 subscriber；
  如果 RACSignalBindBlock 请求终止信号就会向原信号发出 -sendCompleted 消息；
  当所有信号都完成时，会向订阅者发送 -sendCompleted；
  无论何时，如果信号发出错误，都会向订阅者发送 -sendError: 消息。


如果想要了解 -bind: 方法在执行的过程中是如何处理订阅的清理和销毁的，可以阅读文章最后的 -bind: 中对订阅的销毁 部分。

信号的创建

信号的创建过程十分简单，-createSignal: 是推荐的创建信号的方法，方法其实只做了一次转发：

+ (RACSignal *)createSignal:(RACDisposable * (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))didSubscribe {
	return [RACDynamicSignal createSignal:didSubscribe];
}

+ (RACSignal *)createSignal:(RACDisposable * (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))didSubscribe {
	RACDynamicSignal *signal = [[self alloc] init];
	signal-&amp;gt;_didSubscribe = [didSubscribe copy];
	return [signal setNameWithFormat:@&quot;+createSignal:&quot;];
}


该方法其实只是创建了一个 RACDynamicSignal 实例并保存了传入的 didSubscribe 代码块，在每次有订阅者订阅当前信号时，都会执行一遍，向订阅者发送消息。

RACSignal 类簇

虽然 -createSignal: 的方法签名上返回的是 RACSignal 对象的实例，但是实际上这里返回的是 RACDynamicSignal，也就是 RACSignal 的子类；同样，在 ReactiveCocoa 中也有很多其他的 RACSignal 子类。

使用类簇的方式设计的 RACSignal 在创建实例时可能会返回 RACDynamicSignal、RACEmptySignal、RACErrorSignal 和 RACReturnSignal 对象：



其实这几种子类并没有对原有的 RACSignal 做出太大的改变，它们的创建过程也不是特别的复杂，只需要调用 RACSignal 不同的类方法：



RACSignal 只是起到了一个代理的作用，最后的实现过程还是会指向对应的子类：

+ (RACSignal *)error:(NSError *)error {
	return [RACErrorSignal error:error];
}

+ (RACSignal *)empty {
	return [RACEmptySignal empty];
}

+ (RACSignal *)return:(id)value {
	return [RACReturnSignal return:value];
}


以 RACReturnSignal 的创建过程为例：

+ (RACSignal *)return:(id)value {
	RACReturnSignal *signal = [[self alloc] init];
	signal-&amp;gt;_value = value;
	return signal;
}


这个信号的创建过程和 RACDynamicSignal 的初始化过程一样，都非常简单；只是将传入的 value 简单保存一下，在有其他订阅者 -subscribe: 时，向订阅者发送 value：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendNext:self.value];
		[subscriber sendCompleted];
	}];
}


RACEmptySignal 和 RACErrorSignal 的创建过程也异常的简单，只是对传入的数据进行简单的存储，然后在订阅时发送出来：

// RACEmptySignal
+ (RACSignal *)empty {
	return [[[self alloc] init] setNameWithFormat:@&quot;+empty&quot;];
}

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendCompleted];
	}];
}

// RACErrorSignal
+ (RACSignal *)error:(NSError *)error {
	RACErrorSignal *signal = [[self alloc] init];
	signal-&amp;gt;_error = error;
	return signal;
}

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendError:self.error];
	}];
}


这两个创建过程的唯一区别就是一个发送的是『空值』，另一个是 NSError 对象。

信号的订阅与信息的发送

ReactiveCocoa 中信号的订阅与信息的发送过程主要是由 RACSubscriber 类来处理的，而这也是信号的处理过程中最重要的一部分，这一小节会先分析整个工作流程，之后会深入代码的实现。



在信号创建之后调用 -subscribeNext: 方法返回一个 RACDisposable，然而这不是这一流程关心的重点，在订阅过程中生成了一个 RACSubscriber 对象，向这个对象发送消息 -sendNext: 时，就会向所有的订阅者发送消息。

信号的订阅

信号的订阅与 -subscribe: 开头的一系列方法有关：



订阅者可以选择自己想要感兴趣的信息类型 next/error/completed 进行关注，并在对应的信息发生时调用 block 进行处理回调。

所有的方法其实只是对 nextBlock、completedBlock 以及 errorBlock 的组合，这里以其中最长的 -subscribeNext:error:completed: 方法的实现为例（也只需要介绍这一个方法）：

- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock {
	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];
	return [self subscribe:o];
}



  方法中传入的所有 block 参数都应该是非空的。


拿到了传入的 block 之后，使用 +subscriberWithNext:error:completed: 初始化一个 RACSubscriber 对象的实例：

+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed {
	RACSubscriber *subscriber = [[self alloc] init];

	subscriber-&amp;gt;_next = [next copy];
	subscriber-&amp;gt;_error = [error copy];
	subscriber-&amp;gt;_completed = [completed copy];

	return subscriber;
}


在拿到这个对象之后，调用 RACSignal 的 -subscribe: 方法传入订阅者对象：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	NSCAssert(NO, @&quot;This method must be overridden by subclasses&quot;);
	return nil;
}


RACSignal 类中其实并没有实现这个实例方法，需要在上文提到的四个子类对这个方法进行覆写，这里仅分析 RACDynamicSignal 中的方法：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];

    RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
        RACDisposable *innerDisposable = self.didSubscribe(subscriber);
        [disposable addDisposable:innerDisposable];
    }];

    [disposable addDisposable:schedulingDisposable];
    
    return disposable;
}



  这里暂时不需要关注与 RACDisposable 有关的任何内容，我们会在下一节中详细介绍。


RACPassthroughSubscriber 就像它的名字一样，只是对上面创建的订阅者对象进行简单的包装，将所有的消息转发给内部的 innerSubscriber，也就是传入的 RACSubscriber 对象：

- (instancetype)initWithSubscriber:(id&amp;lt;RACSubscriber&amp;gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable {
	self = [super init];

	_innerSubscriber = subscriber;
	_signal = signal;
	_disposable = disposable;

	[self.innerSubscriber didSubscribeWithDisposable:self.disposable];
	return self;
}


如果直接简化 -subscribe: 方法的实现，你可以看到一个看起来极为敷衍的代码：

- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
    return self.didSubscribe(subscriber);
}


方法只是执行了在创建信号时传入的 RACSignalBindBlock：

[RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@&quot;dispose&quot;);
    }];
}];


总而言之，信号的订阅过程就是初始化 RACSubscriber 对象，然后执行 didSubscribe 代码块的过程。



信息的发送

在 RACSignalBindBlock 中，订阅者可以根据自己的兴趣选择自己想要订阅哪种消息；我们也可以按需发送三种消息：



而现在只需要简单看一下这三个方法的实现，就能够明白信息的发送过程了（真是没啥好说的，不过为了凑字数完整性）：

- (void)sendNext:(id)value {
	@synchronized (self) {
		void (^nextBlock)(id) = [self.next copy];
		if (nextBlock == nil) return;

		nextBlock(value);
	}
}


-sendNext: 只是将方法传入的值传入 nextBlock 再调用一次，并没有什么值得去分析的地方，而剩下的两个方法实现也差不多，会调用对应的 block，在这里就省略了。

订阅的回收过程

在创建信号时，我们向 -createSignal: 方法中传入了 didSubscribe 信号，这个 block 在执行结束时会返回一个 RACDisposable 对象，用于在订阅结束时进行必要的清理，同样也可以用于取消因为订阅创建的正在执行的任务。

而处理这些事情的核心类就是 RACDisposable 以及它的子类：




  这篇文章中主要关注的是左侧的三个子类，当然 RACDisposable 的子类不止这三个，还有用于处理 KVO 的 RACKVOTrampoline，不过在这里我们不会讨论这个类的实现。


RACDisposable

在继续分析讨论订阅的回收过程之前，笔者想先对 RACDisposable 进行简要的剖析和介绍：


类 RACDisposable 是以 _disposeBlock 为核心进行组织的，几乎所有的方法以及属性其实都是对 _disposeBlock 进行的操作。

关于 _disposeBlock 中的 self


  这一小节的内容是可选的，跳过不影响整篇文章阅读的连贯性。


_disposeBlock 是一个私有的指针变量，当 void (^)(void) 类型的 block 被传入之后都会转换成 CoreFoundation 中的类型并以 void * 的形式存入 _disposeBlock 中：


+ (instancetype)disposableWithBlock:(void (^)(void))block {
	return [[self alloc] initWithBlock:block];
}

- (instancetype)initWithBlock:(void (^)(void))block {
	self = [super init];

	_disposeBlock = (void *)CFBridgingRetain([block copy]); 
	OSMemoryBarrier();

	return self;
}


奇怪的是，_disposeBlock 中不止会存储代码块 block，还有可能存储桥接之后的 self：

- (instancetype)init {
	self = [super init];

	_disposeBlock = (__bridge void *)self;
	OSMemoryBarrier();

	return self;
}


这里，刚开始看到可能会觉得比较奇怪，有两个疑问需要解决：


  为什么要提供一个 -init 方法来初始化 RACDisposable 对象？
  为什么要向 _disposeBlock 中传入当前对象？


对于 RACDisposable 来说，虽然一个不包含 _disposeBlock 的对象没什么太多的意义，但是对于 RACSerialDisposable 等子类来说，却不完全是这样，因为 RACSerialDisposable 在 -dispose 时，并不需要执行 disposeBlock，这样就浪费了内存和 CPU 时间；但是同时我们需要一个合理的方法准确地判断当前对象的 isDisposed：

- (BOOL)isDisposed {
	return _disposeBlock == NULL;
}


所以，使用向 _disposeBlock 中传入 NULL 的方式来判断 isDisposed；在 -init 调用时传入 self 而不是 NULL 防止状态被误判，这样就在不引入其他实例变量、增加对象的设计复杂度的同时，解决了这两个问题。

如果仍然不理解上述的两个问题，在这里举一个错误的例子，如果 _disposeBlock 在使用时只传入 NULL 或者 block，那么在 RACCompoundDisposable 初始化时，是应该向 _disposeBlock 中传入什么呢？


  传入 NULL 会导致在初始化之后 isDisposed == YES，然而当前对象根本没有被回收；
  传入 block 会导致无用的 block 的执行，浪费内存以及 CPU 时间；


这也就是为什么要引入 self 来作为 _disposeBlock 内容的原因。

-dispose: 方法的实现

这个只有不到 20 行的 -dispose: 方法已经是整个 RACDisposable 类中最复杂的方法了：

- (void)dispose {
	void (^disposeBlock)(void) = NULL;

	while (YES) {
		void *blockPtr = _disposeBlock;
		if (OSAtomicCompareAndSwapPtrBarrier(blockPtr, NULL, &amp;amp;_disposeBlock)) {
			if (blockPtr != (__bridge void *)self) {
				disposeBlock = CFBridgingRelease(blockPtr);
			}

			break;
		}
	}

	if (disposeBlock != nil) disposeBlock();
}


但是其实它的实现也没有复杂到哪里去，从 _disposeBlock 实例变量中调用 CFBridgingRelease 取出一个 disposeBlock，然后执行这个 block，整个方法就结束了。

RACSerialDisposable

RACSerialDisposable 是一个用于持有 RACDisposable 的容器，它一次只能持有一个 RACDisposable 的实例，并可以原子地换出容器中保存的对象：

- (RACDisposable *)swapInDisposable:(RACDisposable *)newDisposable {
	RACDisposable *existingDisposable;
	BOOL alreadyDisposed;

	pthread_mutex_lock(&amp;amp;_mutex);
	alreadyDisposed = _disposed;
	if (!alreadyDisposed) {
		existingDisposable = _disposable;
		_disposable = newDisposable;
	}
	pthread_mutex_unlock(&amp;amp;_mutex);

	if (alreadyDisposed) {
		[newDisposable dispose];
		return nil;
	}

	return existingDisposable;
}


线程安全的 RACSerialDisposable 使用 pthred_mutex_t 互斥锁来保证在访问关键变量时不会出现线程竞争问题。

-dispose 方法的处理也十分简单：

- (void)dispose {
	RACDisposable *existingDisposable;

	pthread_mutex_lock(&amp;amp;_mutex);
	if (!_disposed) {
		existingDisposable = _disposable;
		_disposed = YES;
		_disposable = nil;
	}
	pthread_mutex_unlock(&amp;amp;_mutex);
	
	[existingDisposable dispose];
}


使用锁保证线程安全，并在内部的 _disposable 换出之后在执行 -dispose 方法对订阅进行处理。

RACCompoundDisposable

与 RACSerialDisposable 只负责一个 RACDisposable 对象的释放不同；RACCompoundDisposable 同时负责多个 RACDisposable 对象的释放。

相比于只管理一个 RACDisposable 对象的 RACSerialDisposable，RACCompoundDisposable 由于管理多个对象，其实现更加复杂，而且为了性能和内存占用之间的权衡，其实现方式是通过持有两个实例变量：

@interface RACCompoundDisposable () {
    ...
    RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];

    CFMutableArrayRef _disposables;
    ...
}


在对象持有的 RACDisposable 不超过 RACCompoundDisposableInlineCount 时，都会存储在 _inlineDisposables 数组中，而更多的实例都会存储在 _disposables 中：



RACCompoundDisposable 在使用 -initWithDisposables:初始化时，会初始化两个 RACDisposable 的位置用于加速销毁订阅的过程，同时为了不浪费内存空间，在默认情况下只占用两个位置：

- (instancetype)initWithDisposables:(NSArray *)otherDisposables {
	self = [self init];

	[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, NSUInteger index, BOOL *stop) {
		self-&amp;gt;_inlineDisposables[index] = disposable;
		if (index == RACCompoundDisposableInlineCount - 1) *stop = YES;
	}];

	if (otherDisposables.count &amp;gt; RACCompoundDisposableInlineCount) {
		_disposables = RACCreateDisposablesArray();

		CFRange range = CFRangeMake(RACCompoundDisposableInlineCount, (CFIndex)otherDisposables.count - RACCompoundDisposableInlineCount);
		CFArrayAppendArray(_disposables, (__bridge CFArrayRef)otherDisposables, range);
	}

	return self;
}


如果传入的 otherDisposables 多于 RACCompoundDisposableInlineCount，就会创建一个新的 CFMutableArrayRef 引用，并将剩余的 RACDisposable 全部传入这个数组中。

在 RACCompoundDisposable 中另一个值得注意的方法就是 -addDisposable:

- (void)addDisposable:(RACDisposable *)disposable {
	if (disposable == nil || disposable.disposed) return;

	BOOL shouldDispose = NO;

	pthread_mutex_lock(&amp;amp;_mutex);
	{
		if (_disposed) {
			shouldDispose = YES;
		} else {
			for (unsigned i = 0; i &amp;lt; RACCompoundDisposableInlineCount; i++) {
				if (_inlineDisposables[i] == nil) {
					_inlineDisposables[i] = disposable;
					goto foundSlot;
				}
			}

			if (_disposables == NULL) _disposables = RACCreateDisposablesArray();
			CFArrayAppendValue(_disposables, (__bridge void *)disposable);
		foundSlot:;
		}
	}
	pthread_mutex_unlock(&amp;amp;_mutex);
	if (shouldDispose) [disposable dispose];
}


在向 RACCompoundDisposable 中添加新的 RACDisposable 对象时，会先尝试在 _inlineDisposables 数组中寻找空闲的位置，如果没有找到，就会加入到 _disposables 中；但是，在添加 RACDisposable 的过程中也难免遇到当前 RACCompoundDisposable 已经 dispose 的情况，而这时就会直接 -dispose 刚刚加入的对象。

订阅的销毁过程

在了解了 ReactiveCocoa 中与订阅销毁相关的类，我们就可以继续对 -bind: 方法的分析了，之前在分析该方法时省略了 -bind: 在执行过程中是如何处理订阅的清理和销毁的，所以会省略对于正常值和错误的处理过程，首先来看一下简化后的代码：

- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        __block volatile int32_t signalCount = 1;
        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

        void (^completeSignal)(RACDisposable *) = ...
        void (^addSignal)(RACSignal *) = ...

        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
        [compoundDisposable addDisposable:selfDisposable];
        RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
            BOOL stop = NO;
            id signal = bindingBlock(x, &amp;amp;stop);

            if (signal != nil) addSignal(signal);
            if (signal == nil || stop) {
                [selfDisposable dispose];
                completeSignal(selfDisposable);
            }
        } completed:^{
            completeSignal(selfDisposable);
        }];
        selfDisposable.disposable = bindingDisposable;
        return compoundDisposable;
    }] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];
}


在简化的代码中，订阅的清理是由一个 RACCompoundDisposable 的实例负责的，向这个实例中添加 RACSerialDisposable 以及 RACDisposable 对象，并在 RACCompoundDisposable 销毁时销毁。

completeSignal 和 addSignal 两个 block 主要负责处理新创建信号的清理工作：

void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) {
    if (OSAtomicDecrement32Barrier(&amp;amp;signalCount) == 0) {
        [subscriber sendCompleted];
        [compoundDisposable dispose];
    } else {
        [compoundDisposable removeDisposable:finishedDisposable];
    }
};

void (^addSignal)(RACSignal *) = ^(RACSignal *signal) {
    OSAtomicIncrement32Barrier(&amp;amp;signalCount);
    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
    [compoundDisposable addDisposable:selfDisposable];
    RACDisposable *disposable = [signal completed:^{
        completeSignal(selfDisposable);
    }];
    selfDisposable.disposable = disposable;
};


先通过一个例子来看一下 -bind: 方法调用之后，订阅是如何被清理的：

RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@&quot;Original Signal Dispose.&quot;);
    }];
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSNumber *returnValue = @(value.integerValue);
        return [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
            for (NSInteger i = 0; i &amp;lt; value.integerValue; i++) [subscriber sendNext:returnValue];
            [subscriber sendCompleted];
            return [RACDisposable disposableWithBlock:^{
                NSLog(@&quot;Binding Signal Dispose.&quot;);
            }];
        }];
    };
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;%@&quot;, x);
}];


在每个订阅创建以及所有的值发送之后，订阅就会被就地销毁，调用 disposeBlock，并从 RACCompoundDisposable 实例中移除：

1
Binding Signal Dispose.
2
2
Binding Signal Dispose.
Original Signal Dispose.


原订阅的销毁时间以及绑定信号的控制是由 SignalCount 控制的，其表示 RACCompoundDisposable 中的 RACSerialDisposable 实例的个数，在每次有新的订阅被创建时都会向 RACCompoundDisposable 加入一个新的 RACSerialDisposable，并在订阅发送结束时从数组中移除，整个过程用图示来表示比较清晰：




  紫色的 RACSerialDisposable 为原订阅创建的对象，灰色的为新信号订阅的对象。


总结

这是整个 ReactiveCocoa 源代码分析系列文章的第一篇，想写一个跟这个系列有关的代码已经很久了，文章中对于 RACSignal 进行了一些简单的介绍，项目中绝大多数的方法都是很简洁的，行数并不多，代码的组织方式也很易于理解。虽然没有太多让人意外的东西，不过整个工程还是很值得阅读的。

References


  A Fistful of Monads
  What is (functional) reactive programming?


方法实现对照表


  
    
      方法
      实现
    
  
  
    
      +return:
      RACSignal.m#L89-L91
    
    
       -bind:
      RACSignal.m#L93-176
    
  



  Github Repo：iOS-Source-Code-Analyze

  Follow: Draveness · GitHub

  Source: http://draveness.me/racsignal


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>对象是如何初始化的-iOS</title>
      <url>/ios/2017/02/13/%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</url>
      <content type="text">在之前，我们已经讨论了非常多的问题了，关于 objc 源代码系列的文章也快结束了，其实关于对象是如何初始化的这篇文章本来是我要写的第一篇文章，但是由于有很多前置内容不得不说，所以留到了这里。

+ alloc 和 - init 这一对我们在 iOS 开发中每天都要用到的初始化方法一直困扰着我, 于是笔者仔细研究了一下 objc 源码中 NSObject 如何进行初始化。

在具体分析对象的初始化过程之前，我想先放出结论，以免文章中的细枝末节对读者的理解有所影响；整个对象的初始化过程其实只是为一个分配内存空间，并且初始化 isa_t 结构体的过程。

alloc 方法分析

先来看一下 + alloc 方法的调用栈(在调用栈中省略了很多不必要的方法的调用):

id _objc_rootAlloc(Class cls)
└── static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
    └── id class_createInstance(Class cls, size_t extraBytes)
    	└── id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct, size_t *outAllocatedSize)
            ├── size_t instanceSize(size_t extraBytes)
            ├── void	*calloc(size_t, size_t)
            └── inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)


这个调用栈中的方法涉及了多个文件中的代码，在下面的章节中会对调用的方法逐步进行分析，如果这个调用栈让你觉得很头疼，也不是什么问题。

alloc 的实现

+ (id)alloc {
    return _objc_rootAlloc(self);
}


alloc 方法的实现真的是非常的简单, 它直接调用了另一个私有方法 id _objc_rootAlloc(Class cls)

id _objc_rootAlloc(Class cls) {
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}


这就是上帝类 NSObject 对 callAlloc 的实现，我们省略了非常多的代码，展示了最常见的执行路径：

static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) {
    id obj = class_createInstance(cls, 0);
    return obj;
}

id class_createInstance(Class cls, size_t extraBytes) {
    return _class_createInstanceFromZone(cls, extraBytes, nil);
}


对象初始化中最重要的操作都在 _class_createInstanceFromZone 方法中执行：

static id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) {
    size_t size = cls-&amp;gt;instanceSize(extraBytes);

    id obj = (id)calloc(1, size);
    if (!obj) return nil;
    obj-&amp;gt;initInstanceIsa(cls, hasCxxDtor);

    return obj;
}


对象的大小

在使用 calloc 为对象分配一块内存空间之前，我们要先获取对象在内存的大小：

size_t instanceSize(size_t extraBytes) {
    size_t size = alignedInstanceSize() + extraBytes;
    if (size &amp;lt; 16) size = 16;
    return size;
}

uint32_t alignedInstanceSize() {
    return word_align(unalignedInstanceSize());
}

uint32_t unalignedInstanceSize() {
    assert(isRealized());
    return data()-&amp;gt;ro-&amp;gt;instanceSize;
}


实例大小 instanceSize 会存储在类的 isa_t 结构体中，然后经过对齐最后返回。


  Core Foundation 需要所有的对象的大小都必须大于或等于 16 字节。


在获取对象大小之后，直接调用 calloc 函数就可以为对象分配内存空间了。

isa 的初始化

在对象的初始化过程中除了使用 calloc 来分配内存之外，还需要根据类初始化 isa_t 结构体：

inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) { 
    if (!indexed) {
        isa.cls = cls;
    } else {
        isa.bits = ISA_MAGIC_VALUE;
        isa.has_cxx_dtor = hasCxxDtor;
        isa.shiftcls = (uintptr_t)cls &amp;gt;&amp;gt; 3;
    }
}


上面的代码只是对 isa_t 结构体进行初始化而已：

union isa_t {
   isa_t() { }
   isa_t(uintptr_t value) : bits(value) { }
    
   Class cls;
   uintptr_t bits;
    
   struct {
       uintptr_t indexed           : 1;
       uintptr_t has_assoc         : 1;
       uintptr_t has_cxx_dtor      : 1;
       uintptr_t shiftcls          : 44;
       uintptr_t magic             : 6;
       uintptr_t weakly_referenced : 1;
       uintptr_t deallocating      : 1;
       uintptr_t has_sidetable_rc  : 1;
       uintptr_t extra_rc          : 8;
   };
};



  在这里并不想过多介绍关于 isa_t 结构体的内容，你可以看从 NSObject 的初始化了解 isa 来了解你想知道的关于 isa_t 的全部内容。


init 方法

NSObject 的 - init 方法只是调用了 _objc_rootInit 并返回了当前对象：

- (id)init {
    return _objc_rootInit(self);
}

id _objc_rootInit(id obj) {
    return obj;
}


总结

在 iOS 中一个对象的初始化过程很符合直觉，只是分配内存空间、然后初始化 isa_t 结构体，其实现也并不复杂，这篇文章也是这个系列文章中较为简单并且简短的一篇。


  Follow: Draveness · Github


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>iOS 源代码分析 --- MBProgressHUD</title>
      <url>/ios/2017/02/12/MBProgressHUD/</url>
      <content type="text">MBProgressHUD 是一个为 iOS app 添加透明浮层 HUD 的第三方框架. 作为一个 UI 层面的框架, 它的实现很简单, 但是其中也有一些非常有意思的代码.

MBProgressHUD

MBProgressHUD 是一个 UIView 的子类, 它提供了一系列的创建 HUD 的方法. 我们在这里会主要介绍三种使用 HUD 的方法.


  + showHUDAddedTo:animated:
  - showAnimated:whileExecutingBlock:onQueue:completionBlock:
  - showWhileExecuting:onTarget:withObject:


+ showHUDAddedTo:animated:

MBProgressHUD 提供了一对类方法 + showHUDAddedTo:animated: 和 + hideHUDForView:animated: 来创建和隐藏 HUD, 这是创建和隐藏 HUD 最简单的一组方法

+ (MB_INSTANCETYPE)showHUDAddedTo:(UIView *)view animated:(BOOL)animated {
	MBProgressHUD *hud = [[self alloc] initWithView:view];
	hud.removeFromSuperViewOnHide = YES;
	[view addSubview:hud];
	[hud show:animated];
	return MB_AUTORELEASE(hud);
}


- initWithView:

首先调用 + alloc - initWithView: 方法返回一个 MBProgressHUD 的实例, - initWithView: 方法会调用当前类的 - initWithFrame: 方法.

通过 - initWithFrame: 方法的执行, 会为 MBProgressHUD 的一些属性设置一系列的默认值.

- (id)initWithFrame:(CGRect)frame {
	self = [super initWithFrame:frame];
	if (self) {
		// Set default values for properties
		self.animationType = MBProgressHUDAnimationFade;
		self.mode = MBProgressHUDModeIndeterminate;
		...
		// Make it invisible for now
		self.alpha = 0.0f;

		[self registerForKVO];
		...
	}
	return self;
}


在 MBProgressHUD 初始化的过程中, 有一个需要注意的方法 - registerForKVO, 我们会在之后查看该方法的实现.

- show:

在初始化一个 HUD 并添加到 view 上之后, 这时 HUD 并没有显示出来, 因为在初始化时, view.alpha 被设置为 0. 所以我们接下来会调用 - show: 方法使 HUD 显示到屏幕上.

- (void)show:(BOOL)animated {
    NSAssert([NSThread isMainThread], @&quot;MBProgressHUD needs to be accessed on the main thread.&quot;);
	useAnimation = animated;
	// If the grace time is set postpone the HUD display
	if (self.graceTime &amp;gt; 0.0) {
        NSTimer *newGraceTimer = [NSTimer timerWithTimeInterval:self.graceTime target:self selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO];
        [[NSRunLoop currentRunLoop] addTimer:newGraceTimer forMode:NSRunLoopCommonModes];
        self.graceTimer = newGraceTimer;
	} 
	// ... otherwise show the HUD imediately 
	else {
		[self showUsingAnimation:useAnimation];
	}
}


因为在 iOS 开发中, 对于 UIView 的处理必须在主线程中, 所以在这里我们要先用 [NSThread isMainThread] 来确认当前前程为主线程.

如果 graceTime 为 0, 那么直接调用 - showUsingAnimation: 方法, 否则会创建一个 newGraceTimer 当然这个 timer 对应的 selector 最终调用的也是 - showUsingAnimation: 方法.

- showUsingAnimation:

- (void)showUsingAnimation:(BOOL)animated {
    // Cancel any scheduled hideDelayed: calls
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [self setNeedsDisplay];

	if (animated &amp;amp;&amp;amp; animationType == MBProgressHUDAnimationZoomIn) {
		self.transform = CGAffineTransformConcat(rotationTransform, CGAffineTransformMakeScale(0.5f, 0.5f));
	} else if (animated &amp;amp;&amp;amp; animationType == MBProgressHUDAnimationZoomOut) {
		self.transform = CGAffineTransformConcat(rotationTransform, CGAffineTransformMakeScale(1.5f, 1.5f));
	}
	self.showStarted = [NSDate date];
	// Fade in
	if (animated) {
		[UIView beginAnimations:nil context:NULL];
		[UIView setAnimationDuration:0.30];
		self.alpha = 1.0f;
		if (animationType == MBProgressHUDAnimationZoomIn || animationType == MBProgressHUDAnimationZoomOut) {
			self.transform = rotationTransform;
		}
		[UIView commitAnimations];
	}
	else {
		self.alpha = 1.0f;
	}
}


这个方法的核心功能就是根据 animationType 为 HUD 的出现添加合适的动画.

typedef NS_ENUM(NSInteger, MBProgressHUDAnimation) {
	/** Opacity animation */
	MBProgressHUDAnimationFade,
	/** Opacity + scale animation */
	MBProgressHUDAnimationZoom,
	MBProgressHUDAnimationZoomOut = MBProgressHUDAnimationZoom,
	MBProgressHUDAnimationZoomIn
};


它在方法刚调用时会通过 - cancelPreviousPerformRequestsWithTarget: 移除附加在 HUD 上的所有 selector, 这样可以保证该方法不会多次调用.

同时也会保存 HUD 的出现时间.

self.showStarted = [NSDate date]


+ hideHUDForView:animated:

+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated {
	MBProgressHUD *hud = [self HUDForView:view];
	if (hud != nil) {
		hud.removeFromSuperViewOnHide = YES;
		[hud hide:animated];
		return YES;
	}
	return NO;
}


+ hideHUDForView:animated: 方法的实现和 + showHUDAddedTo:animated: 差不多, + HUDForView: 方法会返回对应 view 最上层的 MBProgressHUD 的实例.

+ (MB_INSTANCETYPE)HUDForView:(UIView *)view {
	NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator];
	for (UIView *subview in subviewsEnum) {
		if ([subview isKindOfClass:self]) {
			return (MBProgressHUD *)subview;
		}
	}
	return nil;
}


然后调用的 - hide: 方法和 - hideUsingAnimation: 方法也没有什么特别的, 只有在 HUD 隐藏之后 - done 负责隐藏执行 completionBlock 和 delegate 回调.

- (void)done {
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	isFinished = YES;
	self.alpha = 0.0f;
	if (removeFromSuperViewOnHide) {
		[self removeFromSuperview];
	}
#if NS_BLOCKS_AVAILABLE
	if (self.completionBlock) {
		self.completionBlock();
		self.completionBlock = NULL;
	}
#endif
	if ([delegate respondsToSelector:@selector(hudWasHidden:)]) {
		[delegate performSelector:@selector(hudWasHidden:) withObject:self];
	}
}


- showAnimated:whileExecutingBlock:onQueue:completionBlock:


  当 block 指定的队列执行时, 显示 HUD, 并在 HUD 消失时, 调用 completion.


同时 MBProgressHUD 也提供一些其他的便利方法实现这一功能:

- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block;
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block completionBlock:(MBProgressHUDCompletionBlock)completion;
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(dispatch_queue_t)queue;


该方法会异步在指定 queue 上运行 block 并在 block 执行结束调用 - cleanUp.

- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(dispatch_queue_t)queue
	 completionBlock:(MBProgressHUDCompletionBlock)completion {
	self.taskInProgress = YES;
	self.completionBlock = completion;
	dispatch_async(queue, ^(void) {
		block();
		dispatch_async(dispatch_get_main_queue(), ^(void) {
			[self cleanUp];
		});
	});
	[self show:animated];
}



关于 - cleanUp 我们会在下一段中介绍.

- showWhileExecuting:onTarget:withObject:


  当一个后台任务在新线程中执行时, 显示 HUD.


- (void)showWhileExecuting:(SEL)method onTarget:(id)target withObject:(id)object animated:(BOOL)animated {
	methodForExecution = method;
	targetForExecution = MB_RETAIN(target);
	objectForExecution = MB_RETAIN(object);	
	// Launch execution in new thread
	self.taskInProgress = YES;
	[NSThread detachNewThreadSelector:@selector(launchExecution) toTarget:self withObject:nil];
	// Show HUD view
	[self show:animated];
}


在保存 methodForExecution targetForExecution 和 objectForExecution 之后, 会在新的线程中调用方法.

- (void)launchExecution {
	@autoreleasepool {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
		// Start executing the requested task
		[targetForExecution performSelector:methodForExecution withObject:objectForExecution];
#pragma clang diagnostic pop
		// Task completed, update view in main thread (note: view operations should
		// be done only in the main thread)
		[self performSelectorOnMainThread:@selector(cleanUp) withObject:nil waitUntilDone:NO];
	}
}


- launchExecution 会创建一个自动释放池, 然后再这个自动释放池中调用方法, 并在方法调用结束之后在主线程执行 - cleanUp.

Trick

在 MBProgressHUD 中有很多神奇的魔法来解决一些常见的问题.

ARC

MBProgressHUD 使用了一系列神奇的宏定义来兼容 MRC.

#ifndef MB_INSTANCETYPE
#if __has_feature(objc_instancetype)
	#define MB_INSTANCETYPE instancetype
#else
	#define MB_INSTANCETYPE id
#endif
#endif

#ifndef MB_STRONG
#if __has_feature(objc_arc)
	#define MB_STRONG strong
#else
	#define MB_STRONG retain
#endif
#endif

#ifndef MB_WEAK
#if __has_feature(objc_arc_weak)
	#define MB_WEAK weak
#elif __has_feature(objc_arc)
	#define MB_WEAK unsafe_unretained
#else
	#define MB_WEAK assign
#endif
#endif


通过宏定义 __has_feature 来判断当前环境是否启用了 ARC, 使得不同环境下宏不会出错.

KVO

MBProgressHUD 通过 @property 生成了一系列的属性.

- (NSArray *)observableKeypaths {
	return [NSArray arrayWithObjects:@&quot;mode&quot;, @&quot;customView&quot;, @&quot;labelText&quot;, @&quot;labelFont&quot;, @&quot;labelColor&quot;,
			@&quot;detailsLabelText&quot;, @&quot;detailsLabelFont&quot;, @&quot;detailsLabelColor&quot;, @&quot;progress&quot;, @&quot;activityIndicatorColor&quot;, nil];
}


这些属性在改变的时候不会, 重新渲染整个 view,  我们在一般情况下覆写 setter 方法, 然后再 setter 方法中刷新对应的属性, 在 MBProgressHUD 中使用 KVO 来解决这个问题.

- (void)registerForKVO {
	for (NSString *keyPath in [self observableKeypaths]) {
		[self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:NULL];
	}
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
	if (![NSThread isMainThread]) {
		[self performSelectorOnMainThread:@selector(updateUIForKeypath:) withObject:keyPath waitUntilDone:NO];
	} else {
		[self updateUIForKeypath:keyPath];
	}
}

- (void)updateUIForKeypath:(NSString *)keyPath {
	if ([keyPath isEqualToString:@&quot;mode&quot;] || [keyPath isEqualToString:@&quot;customView&quot;] ||
		[keyPath isEqualToString:@&quot;activityIndicatorColor&quot;]) {
		[self updateIndicators];
	} else if ([keyPath isEqualToString:@&quot;labelText&quot;]) {
		label.text = self.labelText;
	} else if ([keyPath isEqualToString:@&quot;labelFont&quot;]) {
		label.font = self.labelFont;
	} else if ([keyPath isEqualToString:@&quot;labelColor&quot;]) {
		label.textColor = self.labelColor;
	} else if ([keyPath isEqualToString:@&quot;detailsLabelText&quot;]) {
		detailsLabel.text = self.detailsLabelText;
	} else if ([keyPath isEqualToString:@&quot;detailsLabelFont&quot;]) {
		detailsLabel.font = self.detailsLabelFont;
	} else if ([keyPath isEqualToString:@&quot;detailsLabelColor&quot;]) {
		detailsLabel.textColor = self.detailsLabelColor;
	} else if ([keyPath isEqualToString:@&quot;progress&quot;]) {
		if ([indicator respondsToSelector:@selector(setProgress:)]) {
			[(id)indicator setValue:@(progress) forKey:@&quot;progress&quot;];
		}
		return;
	}
	[self setNeedsLayout];
	[self setNeedsDisplay];
}


- observeValueForKeyPath:ofObject:change:context: 方法中的代码是为了保证 UI 的更新一定是在主线程中, 而 - updateUIForKeypath: 方法负责 UI 的更新.

End

MBProgressHUD 由于是一个 UI 的第三方库, 所以它的实现还是挺简单的.



Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>CocoaPods 都做了什么？</title>
      <url>/ios/2017/01/07/CocoaPods-%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      <content type="text">稍有 iOS 开发经验的人应该都是用过 CocoaPods，而对于 CI、CD 有了解的同学也都知道 Fastlane。而这两个在 iOS 开发中非常便捷的第三方库都是使用 Ruby 来编写的，这是为什么？

先抛开这个话题不谈，我们来看一下 CocoaPods 和 Fastlane 是如何使用的，首先是 CocoaPods，在每一个使用 CocoaPods 的工程中都有一个 Podfile：

source 'https://github.com/CocoaPods/Specs.git'

target 'Demo' do
	pod 'Mantle', '~&amp;gt; 1.5.1'
	pod 'SDWebImage', '~&amp;gt; 3.7.1'
	pod 'BlocksKit', '~&amp;gt; 2.2.5'
	pod 'SSKeychain', '~&amp;gt; 1.2.3'
	pod 'UMengAnalytics', '~&amp;gt; 3.1.8'
	pod 'UMengFeedback', '~&amp;gt; 1.4.2'
	pod 'Masonry', '~&amp;gt; 0.5.3'
	pod 'AFNetworking', '~&amp;gt; 2.4.1'
	pod 'Aspects', '~&amp;gt; 1.4.1'
end



这是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：

source('https://github.com/CocoaPods/Specs.git')

target('Demo') do
	pod('Mantle', '~&amp;gt; 1.5.1')
	...
end




  Ruby 代码在调用方法时可以省略括号。


Podfile 中对于约束的描述，其实都可以看作是对代码简写，上面的代码在解析时可以当做 Ruby 代码来执行。

Fastlane 中的代码 Fastfile 也是类似的：

lane :beta do
  increment_build_number
  cocoapods
  match
  testflight
  sh &quot;./customScript.sh&quot;
  slack
end



使用描述性的”代码“编写脚本，如果没有接触或者使用过 Ruby 的人很难相信上面的这些文本是代码的。

Ruby 概述

在介绍 CocoaPods 的实现之前，我们需要对 Ruby 的一些特性有一个简单的了解，在向身边的朋友“传教”的时候，我往往都会用优雅这个词来形容这门语言（手动微笑）。

除了优雅之外，Ruby 的语法具有强大的表现力，并且其使用非常灵活，能快速实现我们的需求，这里简单介绍一下 Ruby 中的一些特性。

一切皆对象

在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 1 + 1，其实只是 1.+(1) 的语法糖而已。

得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 methods 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 methods 来“查文档”：

2.3.1 :003 &amp;gt; 1.methods
 =&amp;gt; [:%, :&amp;amp;, :*, :+, :-, :/, :&amp;lt;, :&amp;gt;, :^, :|, :~, :-@, :**, :&amp;lt;=&amp;gt;, :&amp;lt;&amp;lt;, :&amp;gt;&amp;gt;, :&amp;lt;=, :&amp;gt;=, :==, :===, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :divmod, :fdiv, :modulo, :abs, :magnitude, :zero?, :odd?, :even?, :bit_length, :to_int, :to_i, :next, :upto, :chr, :ord, :integer?, :floor, :ceil, :round, :truncate, :downto, :times, :pred, :to_r, :numerator, :denominator, :rationalize, :gcd, :lcm, :gcdlcm, :+@, :eql?, :singleton_method_added, :coerce, :i, :remainder, :real?, :nonzero?, :step, :positive?, :negative?, :quo, :arg, :rectangular, :rect, :polar, :real, :imaginary, :imag, :abs2, :angle, :phase, :conjugate, :conj, :to_c, :between?, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :is_a?, :extend, :define_singleton_method, :to_enum, :enum_for, :=~, :!~, :respond_to?, :freeze, :display, :send, :object_id, :method, :public_method, :singleton_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]



比如在这里向对象 1 调用 methods 就会返回它能响应的所有方法。

一切皆对象不仅减少了语言中类型的不一致，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了语言中的组成元素，这样 Ruby 中只有对象和方法，这两个概念，这也降低了我们理解这门语言的复杂度：


  使用对象存储状态
  对象之间通过方法通信


block

Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。

首先 Ruby 中的 block 也是一种对象，所有的 Block 都是 Proc 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。

def twice(&amp;amp;proc)
	2.times { proc.call() } if proc
end

def twice
	2.times { yield } if block_given?
end




  yield 会调用外部传入的 block，block_given? 用于判断当前方法是否传入了 block。


在这个方法调用时，是这样的：

twice do 
	puts &quot;Hello&quot;
end



eval

最后一个需要介绍的特性就是 eval 了，早在几十年前的 Lisp 语言就有了 eval 这个方法，这个方法会将字符串当做代码来执行，也就是说 eval 模糊了代码与数据之间的边界。

&amp;gt; eval &quot;1 + 2 * 3&quot;
 =&amp;gt; 7



有了 eval 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码；而不需要去手动解析输入、生成语法树。

手动解析 Podfile

在我们对 Ruby 这门语言有了一个简单的了解之后，就可以开始写一个简易的解析 Podfile 的脚本了。

在这里，我们以一个非常简单的 Podfile 为例，使用 Ruby 脚本解析 Podfile 中指定的依赖：

source 'http://source.git'
platform :ios, '8.0'

target 'Demo' do
    pod 'AFNetworking'
    pod 'SDWebImage'
    pod 'Masonry'
    pod &quot;Typeset&quot;
    pod 'BlocksKit'
    pod 'Mantle'
    pod 'IQKeyboardManager'
    pod 'IQDropDownTextField'
end



因为这里的 source、platform、target 以及 pod 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：

# eval_pod.rb
$hash_value = {}

def source(url)
end

def target(target)
end

def platform(platform, version)
end

def pod(pod)
end



使用一个全局变量 hash_value 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行会不会有什么问题。

在 eval_pod.rb 文件的最下面加入这几行代码：

content = File.read './Podfile'
eval content
p $hash_value



这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 hash_value 的值。

$ ruby eval_pod.rb



运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：

def source(url)
    $hash_value['source'] = url
end

def target(target)
    targets = $hash_value['targets']
    targets = [] if targets == nil
    targets &amp;lt;&amp;lt; target
    $hash_value['targets'] = targets
    yield if block_given?
end

def platform(platform, version)
end

def pod(pod)
    pods = $hash_value['pods']
    pods = [] if pods == nil
    pods &amp;lt;&amp;lt; pod
    $hash_value['pods'] = pods
end



在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：

$ ruby eval_pod.rb
{&quot;source&quot;=&amp;gt;&quot;http://source.git&quot;, &quot;targets&quot;=&amp;gt;[&quot;Demo&quot;], &quot;pods&quot;=&amp;gt;[&quot;AFNetworking&quot;, &quot;SDWebImage&quot;, &quot;Masonry&quot;, &quot;Typeset&quot;, &quot;BlocksKit&quot;, &quot;Mantle&quot;, &quot;IQKeyboardManager&quot;, &quot;IQDropDownTextField&quot;]}



CocoaPods 中对于 Podfile 的解析与这里的实现其实差不多，接下来就进入了 CocoaPods 的实现部分了。

CocoaPods 的实现

在上面简单介绍了 Ruby 的一些语法以及如何解析 Podfile 之后，我们开始深入了解一下 CocoaPods 是如何管理 iOS 项目的依赖，也就是 pod install 到底做了些什么。

Pod install 的过程

pod install 这个命令到底做了什么？首先，在 CocoaPods 中，所有的命令都会由 Command 类派发到将对应的类，而真正执行 pod install 的类就是 Install：

module Pod
  class Command
	class Install &amp;lt; Command
	  def run
		verify_podfile_exists!
		installer = installer_for_config
		installer.repo_update = repo_update?(:default =&amp;gt; false)
		installer.update = false
		installer.install!
	  end
	end
  end
end



这里面会从配置类的实例 config 中获取一个 Installer 的实例，然后执行 install! 方法，这里的 installer 有一个 update 属性，而这也就是 pod install 和 update 之间最大的区别，其中后者会无视已有的 Podfile.lock 文件，重新对依赖进行分析：

module Pod
  class Command
	class Update &amp;lt; Command
	  def run
		...

		installer = installer_for_config
		installer.repo_update = repo_update?(:default =&amp;gt; true)
		installer.update = true
		installer.install!
	  end
	end
  end
end



Podfile 的解析

Podfile 中依赖的解析其实是与我们在手动解析 Podfile 章节所介绍的差不多，整个过程主要都是由 CocoaPods-Core 这个模块来完成的，而这个过程早在 installer_for_config 中就已经开始了：

def installer_for_config
  Installer.new(config.sandbox, config.podfile, config.lockfile)
end



这个方法会从 config.podfile 中取出一个 Podfile 类的实例：

def podfile
  @podfile ||= Podfile.from_file(podfile_path) if podfile_path
end



类方法 Podfile.from_file 就定义在 CocoaPods-Core 这个库中，用于分析 Podfile 中定义的依赖，这个方法会根据 Podfile 不同的类型选择不同的调用路径：

Podfile.from_file
`-- Podfile.from_ruby
	|-- File.open
	`-- eval



from_ruby 类方法就会像我们在前面做的解析 Podfile 的方法一样，从文件中读取数据，然后使用 eval 直接将文件中的内容当做 Ruby 代码来执行。

def self.from_ruby(path, contents = nil)
  contents ||= File.open(path, 'r:utf-8', &amp;amp;:read)

  podfile = Podfile.new(path) do
	begin
	  eval(contents, nil, path.to_s)
	rescue Exception =&amp;gt; e
	  message = &quot;Invalid `#{path.basename}` file: #{e.message}&quot;
	  raise DSLError.new(message, path, e, contents)
	end
  end
  podfile
end



在 Podfile 这个类的顶部，我们使用 Ruby 的 Mixin 的语法来混入 Podfile 中代码执行所需要的上下文：

include Pod::Podfile::DSL



Podfile 中的所有你见到的方法都是定义在 DSL 这个模块下面的：

module Pod
  class Podfile
	module DSL
	  def pod(name = nil, *requirements) end
	  def target(name, options = nil) end
	  def platform(name, target = nil) end
	  def inhibit_all_warnings! end
	  def use_frameworks!(flag = true) end
	  def source(source) end
	  ...
	end
  end
end



这里定义了很多 Podfile 中使用的方法，当使用 eval 执行文件中的代码时，就会执行这个模块里的方法，在这里简单看一下其中几个方法的实现，比如说 source 方法：

def source(source)
  hash_sources = get_hash_value('sources') || []
  hash_sources &amp;lt;&amp;lt; source
  set_hash_value('sources', hash_sources.uniq)
end



该方法会将新的 source 加入已有的源数组中，然后更新原有的 sources 对应的值。

稍微复杂一些的是 target 方法：

def target(name, options = nil)
  if options
	raise Informative, &quot;Unsupported options `#{options}` for &quot; \
	  &quot;target `#{name}`.&quot;
  end

  parent = current_target_definition
  definition = TargetDefinition.new(name, parent)
  self.current_target_definition = definition
  yield if block_given?
ensure
  self.current_target_definition = parent
end



这个方法会创建一个 TargetDefinition 类的实例，然后将当前环境系的 target_definition 设置成这个刚刚创建的实例。这样，之后使用 pod 定义的依赖都会填充到当前的 TargetDefinition 中：

def pod(name = nil, *requirements)
  unless name
	raise StandardError, 'A dependency requires a name.'
  end

  current_target_definition.store_pod(name, *requirements)
end



当 pod 方法被调用时，会执行 store_pod 将依赖存储到当前 target 中的 dependencies 数组中：

def store_pod(name, *requirements)
  return if parse_subspecs(name, requirements)
  parse_inhibit_warnings(name, requirements)
  parse_configuration_whitelist(name, requirements)

  if requirements &amp;amp;&amp;amp; !requirements.empty?
	pod = { name =&amp;gt; requirements }
  else
	pod = name
  end

  get_hash_value('dependencies', []) &amp;lt;&amp;lt; pod
  nil
end



总结一下，CocoaPods 对 Podfile 的解析与我们在前面做的手动解析 Podfile 的原理差不多，构建一个包含一些方法的上下文，然后直接执行 eval 方法将文件的内容当做代码来执行，这样只要 Podfile 中的数据是符合规范的，那么解析 Podfile 就是非常简单容易的。

安装依赖的过程

Podfile 被解析后的内容会被转化成一个 Podfile 类的实例，而 Installer 的实例方法 install! 就会使用这些信息安装当前工程的依赖，而整个安装依赖的过程大约有四个部分：


  解析 Podfile 中的依赖
  下载依赖
  创建 Pods.xcodeproj 工程
  集成 workspace


def install!
  resolve_dependencies
  download_dependencies
  generate_pods_project
  integrate_user_project
end



在上面的 install 方法调用的 resolve_dependencies 会创建一个 Analyzer 类的实例，在这个方法中，你会看到一些非常熟悉的字符串：

def resolve_dependencies
  analyzer = create_analyzer

  plugin_sources = run_source_provider_hooks
  analyzer.sources.insert(0, *plugin_sources)

  UI.section 'Updating local specs repositories' do
	analyzer.update_repositories
  end if repo_update?

  UI.section 'Analyzing dependencies' do
	analyze(analyzer)
	validate_build_configurations
	clean_sandbox
  end
end



在使用 CocoaPods 中经常出现的 Updating local specs repositories 以及 Analyzing dependencies 就是从这里输出到终端的，该方法不仅负责对本地所有 PodSpec 文件的更新，还会对当前 Podfile 中的依赖进行分析：

def analyze(analyzer = create_analyzer)
  analyzer.update = update
  @analysis_result = analyzer.analyze
  @aggregate_targets = analyzer.result.targets
end



analyzer.analyze 方法最终会调用 Resolver 的实例方法 resolve：

def resolve
  dependencies = podfile.target_definition_list.flat_map do |target|
	target.dependencies.each do |dep|
	  @platforms_by_dependency[dep].push(target.platform).uniq! if target.platform
	end
  end
  @activated = Molinillo::Resolver.new(self, self).resolve(dependencies, locked_dependencies)
  specs_by_target
rescue Molinillo::ResolverError =&amp;gt; e
  handle_resolver_error(e)
end



这里的 Molinillo::Resolver 就是用于解决依赖关系的类。

解决依赖关系（Resolve Dependencies）

CocoaPods 为了解决 Podfile 中声明的依赖关系，使用了一个叫做 Milinillo 的依赖关系解决算法；但是，笔者在 Google 上并没有找到与这个算法相关的其他信息，推测是 CocoaPods 为了解决 iOS 中的依赖关系创造的算法。

Milinillo 算法的核心是 回溯（Backtracking） 以及 向前检查（forward check），整个过程会追踪栈中的两个状态（依赖和可能性）。

在这里并不想陷入对这个算法执行过程的分析之中，如果有兴趣可以看一下仓库中的 ARCHITECTURE.md 文件，其中比较详细的解释了 Milinillo 算法的工作原理，并对其功能执行过程有一个比较详细的介绍。

Molinillo::Resolver 方法会返回一个依赖图，其内容大概是这样的：

Molinillo::DependencyGraph:[
	Molinillo::DependencyGraph::Vertex:AFNetworking(#&amp;lt;Pod::Specification name=&quot;AFNetworking&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:SDWebImage(#&amp;lt;Pod::Specification name=&quot;SDWebImage&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:Masonry(#&amp;lt;Pod::Specification name=&quot;Masonry&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:Typeset(#&amp;lt;Pod::Specification name=&quot;Typeset&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:CCTabBarController(#&amp;lt;Pod::Specification name=&quot;CCTabBarController&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:BlocksKit(#&amp;lt;Pod::Specification name=&quot;BlocksKit&quot;&amp;gt;),
	Molinillo::DependencyGraph::Vertex:Mantle(#&amp;lt;Pod::Specification name=&quot;Mantle&quot;&amp;gt;),
	...
]



这个依赖图是由一个结点数组组成的，在 CocoaPods 拿到了这个依赖图之后，会在 specs_by_target 中按照 Target 将所有的 Specification 分组：

{
	#&amp;lt;Pod::Podfile::TargetDefinition label=Pods&amp;gt;=&amp;gt;[],
	#&amp;lt;Pod::Podfile::TargetDefinition label=Pods-Demo&amp;gt;=&amp;gt;[
		#&amp;lt;Pod::Specification name=&quot;AFNetworking&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;AFNetworking/NSURLSession&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;AFNetworking/Reachability&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;AFNetworking/Security&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;AFNetworking/Serialization&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;AFNetworking/UIKit&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;BlocksKit/Core&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;BlocksKit/DynamicDelegate&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;BlocksKit/MessageUI&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;BlocksKit/UIKit&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;CCTabBarController&quot;&amp;gt;,
		#&amp;lt;Pod::Specification name=&quot;CategoryCluster&quot;&amp;gt;,
		...
	]
}



而这些 Specification 就包含了当前工程依赖的所有第三方框架，其中包含了名字、版本、源等信息，用于依赖的下载。

下载依赖

在依赖关系解决返回了一系列 Specification 对象之后，就到了 Pod install 的第二部分，下载依赖：

def install_pod_sources
  @installed_specs = []
  pods_to_install = sandbox_state.added | sandbox_state.changed
  title_options = { :verbose_prefix =&amp;gt; '-&amp;gt; '.green }
  root_specs.sort_by(&amp;amp;:name).each do |spec|
	if pods_to_install.include?(spec.name)
	  if sandbox_state.changed.include?(spec.name) &amp;amp;&amp;amp; sandbox.manifest
		previous = sandbox.manifest.version(spec.name)
		title = &quot;Installing #{spec.name} #{spec.version} (was #{previous})&quot;
	  else
		title = &quot;Installing #{spec}&quot;
	  end
	  UI.titled_section(title.green, title_options) do
		install_source_of_pod(spec.name)
	  end
	else
	  UI.titled_section(&quot;Using #{spec}&quot;, title_options) do
		create_pod_installer(spec.name)
	  end
	end
  end
end



在这个方法中你会看到更多熟悉的提示，CocoaPods 会使用沙盒（sandbox）存储已有依赖的数据，在更新现有的依赖时，会根据依赖的不同状态显示出不同的提示信息：

-&amp;gt; Using AFNetworking (3.1.0)

-&amp;gt; Using AKPickerView (0.2.7)

-&amp;gt; Using BlocksKit (2.2.5) was (2.2.4)

-&amp;gt; Installing MBProgressHUD (1.0.0)
...



虽然这里的提示会有三种，但是 CocoaPods 只会根据不同的状态分别调用两种方法：


  install_source_of_pod
  create_pod_installer


create_pod_installer 方法只会创建一个 PodSourceInstaller 的实例，然后加入 pod_installers 数组中，因为依赖的版本没有改变，所以不需要重新下载，而另一个方法的 install_source_of_pod 的调用栈非常庞大：

installer.install_source_of_pod
|-- create_pod_installer
|	`-- PodSourceInstaller.new
`-- podSourceInstaller.install!
	`-- download_source
	   `-- Downloader.download
		   `-- Downloader.download_request
			   `-- Downloader.download_source
				   |-- Downloader.for_target
				   |   |-- Downloader.class_for_options
				   |   `-- Git/HTTP/Mercurial/Subversion.new
				   |-- Git/HTTP/Mercurial/Subversion.download
				   `-- Git/HTTP/Mercurial/Subversion.download!
					   `-- Git.clone



在调用栈的末端 Downloader.download_source 中执行了另一个 CocoaPods 组件 CocoaPods-Download 中的方法：

def self.download_source(target, params)
  FileUtils.rm_rf(target)
  downloader = Downloader.for_target(target, params)
  downloader.download
  target.mkpath

  if downloader.options_specific?
	params
  else
	downloader.checkout_options
  end
end



方法中调用的 for_target 根据不同的源会创建一个下载器，因为依赖可能通过不同的协议或者方式进行下载，比如说 Git/HTTP/SVN 等等，组件 CocoaPods-Downloader 就会根据 Podfile 中依赖的参数选项使用不同的方法下载依赖。

大部分的依赖都会被下载到 ~/Library/Caches/CocoaPods/Pods/Release/ 这个文件夹中，然后从这个这里复制到项目工程目录下的 ./Pods 中，这也就完成了整个 CocoaPods 的下载流程。

生成 Pods.xcodeproj

CocoaPods 通过组件 CocoaPods-Downloader 已经成功将所有的依赖下载到了当前工程中，这里会将所有的依赖打包到 Pods.xcodeproj 中：

def generate_pods_project(generator = create_generator)
  UI.section 'Generating Pods project' do
	generator.generate!
	@pods_project = generator.project
	run_podfile_post_install_hooks
	generator.write
	generator.share_development_pod_schemes
	write_lockfiles
  end
end



generate_pods_project 中会执行 PodsProjectGenerator 的实例方法 generate!：

def generate!
  prepare
  install_file_references
  install_libraries
  set_target_dependencies
end



这个方法做了几件小事：


  生成 Pods.xcodeproj 工程
  将依赖中的文件加入工程
  将依赖中的 Library 加入工程
  设置目标依赖（Target Dependencies）


这几件事情都离不开 CocoaPods 的另外一个组件 Xcodeproj，这是一个可以操作一个 Xcode 工程中的 Group 以及文件的组件，我们都知道对 Xcode 工程的修改大多数情况下都是对一个名叫 project.pbxproj 的文件进行修改，而 Xcodeproj 这个组件就是 CocoaPods 团队开发的用于操作这个文件的第三方库。

生成 workspace

最后的这一部分与生成 Pods.xcodeproj 的过程有一些相似，这里使用的类是 UserProjectIntegrator，调用方法 integrate! 时，就会开始集成工程所需要的 Target：

def integrate!
  create_workspace
  integrate_user_targets
  warn_about_xcconfig_overrides
  save_projects
end



对于这一部分的代码，也不是很想展开来细谈，简单介绍一下这里的代码都做了什么，首先会通过 Xcodeproj::Workspace 创建一个 workspace，之后会获取所有要集成的 Target 实例，调用它们的 integrate! 方法：

def integrate!
  UI.section(integration_message) do
	XCConfigIntegrator.integrate(target, native_targets)

	add_pods_library
	add_embed_frameworks_script_phase
	remove_embed_frameworks_script_phase_from_embedded_targets
	add_copy_resources_script_phase
	add_check_manifest_lock_script_phase
  end
end



方法将每一个 Target 加入到了工程，使用 Xcodeproj 修改 Copy Resource Script Phrase 等设置，保存 project.pbxproj，整个 Pod install 的过程就结束了。

总结

最后想说的是 pod install 和 pod update 区别还是比较大的，每次在执行 pod install 或者 update 时最后都会生成或者修改 Podfile.lock 文件，其中前者并不会修改 Podfile.lock 中显示指定的版本，而后者会会无视该文件的内容，尝试将所有的 pod 更新到最新版。

CocoaPods 工程的代码虽然非常多，不过代码的逻辑非常清晰，整个管理并下载依赖的过程非常符合直觉以及逻辑。

其它


  Github Repo：iOS-Source-Code-Analyze

  Source: http://draveness.me/cocoapods


</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>验证 HTTPS 请求的证书（五）</title>
      <url>/ios/2016/12/06/%E9%AA%8C%E8%AF%81-HTTPS-%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6-%E4%BA%94/</url>
      <content type="text">
  文章来自验证 HTTPS 请求的证书（五）



  作者Blog: Draveness


自 iOS9 发布之后，由于新特性 App Transport Security 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 AFNetworking 中的 AFSecurityPolicy 就是为了阻止中间人攻击，以及其它漏洞的工具。

AFSecurityPolicy 主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。

AFSSLPinningMode

使用 AFSecurityPolicy 时，总共有三种验证服务器是否被信任的方式：

typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {
    AFSSLPinningModeNone,
    AFSSLPinningModePublicKey,
    AFSSLPinningModeCertificate,
};



  AFSSLPinningModeNone 是默认的认证方式，只会在系统的信任的证书列表中对服务端返回的证书进行验证
  AFSSLPinningModeCertificate 需要客户端预先保存服务端的证书
  AFSSLPinningModePublicKey 也需要预先保存服务端发送的证书，但是这里只会验证证书中的公钥是否正确


初始化以及设置

在使用 AFSecurityPolicy 验证服务端是否受到信任之前，要对其进行初始化，使用初始化方法时，主要目的是设置验证服务器是否受信任的方式。

+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode {
    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];
}

+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates {
    AFSecurityPolicy *securityPolicy = [[self alloc] init];
    securityPolicy.SSLPinningMode = pinningMode;

    [securityPolicy setPinnedCertificates:pinnedCertificates];

    return securityPolicy;
}


这里没有什么地方值得解释的。不过在调用 pinnedCertificate 的 setter 方法时，会从全部的证书中取出公钥保存到 pinnedPublicKeys 属性中。

- (void)setPinnedCertificates:(NSSet *)pinnedCertificates {
    _pinnedCertificates = pinnedCertificates;

    if (self.pinnedCertificates) {
        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];
        for (NSData *certificate in self.pinnedCertificates) {
            id publicKey = AFPublicKeyForCertificate(certificate);
            if (!publicKey) {
                continue;
            }
            [mutablePinnedPublicKeys addObject:publicKey];
        }
        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];
    } else {
        self.pinnedPublicKeys = nil;
    }
}


在这里调用了 AFPublicKeyForCertificate 对证书进行操作，返回一个公钥。

操作 SecTrustRef

对 serverTrust 的操作的函数基本上都是 C 的 API，都定义在 Security 模块中，先来分析一下在上一节中 AFPublicKeyForCertificate 的实现

static id AFPublicKeyForCertificate(NSData *certificate) {
    id allowedPublicKey = nil;
    SecCertificateRef allowedCertificate;
    SecCertificateRef allowedCertificates[1];
    CFArrayRef tempCertificates = nil;
    SecPolicyRef policy = nil;
    SecTrustRef allowedTrust = nil;
    SecTrustResultType result;

    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
    __Require_Quiet(allowedCertificate != NULL, _out);

    allowedCertificates[0] = allowedCertificate;
    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);

    policy = SecPolicyCreateBasicX509();
    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;amp;allowedTrust), _out);
    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;amp;result), _out);

    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);

_out:
    if (allowedTrust) {
        CFRelease(allowedTrust);
    }

    if (policy) {
        CFRelease(policy);
    }

    if (tempCertificates) {
        CFRelease(tempCertificates);
    }

    if (allowedCertificate) {
        CFRelease(allowedCertificate);
    }

    return allowedPublicKey;
}



  
    初始化一坨临时变量

     id allowedPublicKey = nil;
 SecCertificateRef allowedCertificate;
 SecCertificateRef allowedCertificates[1];
 CFArrayRef tempCertificates = nil;
 SecPolicyRef policy = nil;
 SecTrustRef allowedTrust = nil;
 SecTrustResultType result;

  
  
    使用 SecCertificateCreateWithData 通过 DER 表示的数据生成一个 SecCertificateRef，然后判断返回值是否为 NULL

     allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
 __Require_Quiet(allowedCertificate != NULL, _out);


    
      
        这里使用了一个非常神奇的宏 __Require_Quiet，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行

          #ifndef __Require_Quiet
      #define __Require_Quiet(assertion, exceptionLabel)                            \
        do                                                                          \
        {                                                                           \
            if ( __builtin_expect(!(assertion), 0) )                                \
            {                                                                       \
                goto exceptionLabel;                                                \
            }                                                                       \
        } while ( 0 )
  #endif

      
    
  
  
    通过上面的 allowedCertificate 创建一个 CFArray

     allowedCertificates[0] = allowedCertificate;
 tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);


    
      下面的 SecTrustCreateWithCertificates 只会接收数组作为参数。
    
  
  
    创建一个默认的符合 X509 标准的 SecPolicyRef，通过默认的 SecPolicyRef 和证书创建一个 SecTrustRef 用于信任评估，对该对象进行信任评估，确认生成的 SecTrustRef 是值得信任的。

         policy = SecPolicyCreateBasicX509();
     __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;amp;allowedTrust), _out);
     __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;amp;result), _out);


    
      这里使用的 __Require_noErr_Quiet 和上面的宏差不多，只是会根据返回值判断是否存在错误。
    
  
  
    获取公钥

     allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);


    
      这里的 __bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放。
    
  
  
    释放各种 C 语言指针

     if (allowedTrust) {
     CFRelease(allowedTrust);
 }
	
 if (policy) {
     CFRelease(policy);
 }
	
 if (tempCertificates) {
     CFRelease(tempCertificates);
 }
	
 if (allowedCertificate) {
     CFRelease(allowedCertificate);
 }

  



  每一个 SecTrustRef 的对象都是包含多个 SecCertificateRef 和 SecPolicyRef。其中 SecCertificateRef 可以使用 DER 进行表示，并且其中存储着公钥信息。


对它的操作还有 AFCertificateTrustChainForServerTrust 和 AFPublicKeyTrustChainForServerTrust 但是它们几乎调用了相同的 API。

static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) {
    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];

    for (CFIndex i = 0; i &amp;lt; certificateCount; i++) {
        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
        [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)];
    }

    return [NSArray arrayWithArray:trustChain];
}



  SecTrustGetCertificateAtIndex 获取 SecTrustRef 中的证书
  SecCertificateCopyData 从证书中或者 DER 表示的数据


验证服务端是否受信

验证服务端是否守信是通过 - [AFSecurityPolicy evaluateServerTrust:forDomain:] 方法进行的。

- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                  forDomain:(NSString *)domain
{

	#1: 不能隐式地信任自己签发的证书
	
	#2: 设置 policy
	
	#3: 验证证书是否有效
	
	#4: 根据 SSLPinningMode 对服务端进行验证
    
    return NO;
}



  
    不能隐式地信任自己签发的证书

     if (domain &amp;amp;&amp;amp; self.allowInvalidCertificates &amp;amp;&amp;amp; self.validatesDomainName &amp;amp;&amp;amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {
     NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);
     return NO;
 }


    
      Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).
Instead, add your own (self-signed) CA certificate to the list of trusted anchors.
    

    
      所以如果没有提供证书或者不验证证书，并且还设置 allowInvalidCertificates 为真，满足上面的所有条件，说明这次的验证是不安全的，会直接返回 NO
    
  
  
    设置 policy

     NSMutableArray *policies = [NSMutableArray array];
 if (self.validatesDomainName) {
     [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
 } else {
     [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];
 }


    
      如果要验证域名的话，就以域名为参数创建一个 SecPolicyRef，否则会创建一个符合 X509 标准的默认 SecPolicyRef 对象
    
  
  
    验证证书的有效性

     if (self.SSLPinningMode == AFSSLPinningModeNone) {
     return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);
 } else if (!AFServerTrustIsValid(serverTrust) &amp;amp;&amp;amp; !self.allowInvalidCertificates) {
     return NO;
 }


    
      如果只根据信任列表中的证书进行验证，即 self.SSLPinningMode == AFSSLPinningModeNone。如果允许无效的证书的就会直接返回 YES。不允许就会对服务端信任进行验证。
      如果服务器信任无效，并且不允许无效证书，就会返回 NO
    
  
  
    根据 SSLPinningMode 对服务器信任进行验证

     switch (self.SSLPinningMode) {
     case AFSSLPinningModeNone:
     default:
         return NO;
     case AFSSLPinningModeCertificate: {
         ...
     }
     case AFSSLPinningModePublicKey: {
         ...
     }
 }


    
      AFSSLPinningModeNone 直接返回 NO
      
        AFSSLPinningModeCertificate

          NSMutableArray *pinnedCertificates = [NSMutableArray array];
  for (NSData *certificateData in self.pinnedCertificates) {
      [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
  }
  SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);
		
  if (!AFServerTrustIsValid(serverTrust)) {
      return NO;
  }
		
  // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)
  NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);
		
  for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) {
      if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
          return YES;
      }
  }
		
  return NO;


        
          从 self.pinnedCertificates 中获取 DER 表示的数据
          使用 SecTrustSetAnchorCertificates 为服务器信任设置证书
          判断服务器信任的有效性
          使用 AFCertificateTrustChainForServerTrust 获取服务器信任中的全部 DER 表示的证书
          如果 pinnedCertificates 中有相同的证书，就会返回 YES
        
      
      
        AFSSLPinningModePublicKey

          NSUInteger trustedPublicKeyCount = 0;
  NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);
		
  for (id trustChainPublicKey in publicKeys) {
      for (id pinnedPublicKey in self.pinnedPublicKeys) {
          if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
              trustedPublicKeyCount += 1;
          }
      }
  }
  return trustedPublicKeyCount &amp;gt; 0;


        
          这部分的实现和上面的差不多，区别有两点
            
              会从服务器信任中获取公钥
              pinnedPublicKeys 中的公钥与服务器信任中的公钥相同的数量大于 0，就会返回真
            
          
        
      
    
  


与 AFURLSessionManager 协作

在代理协议 - URLSession:didReceiveChallenge:completionHandler: 或者 - URLSession:task:didReceiveChallenge:completionHandler: 代理方法被调用时会运行这段代码

if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
    if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
        disposition = NSURLSessionAuthChallengeUseCredential;
        credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
    } else {
        disposition = NSURLSessionAuthChallengeRejectProtectionSpace;
    }
} else {
    disposition = NSURLSessionAuthChallengePerformDefaultHandling;
}


NSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。

在上面的方法中，如果保护空间中的认证方法为 NSURLAuthenticationMethodServerTrust，那么就会使用在上一小节中提到的方法 - [AFSecurityPolicy evaluateServerTrust:forDomain:] 对保护空间中的 serverTrust 以及域名 host 进行认证

根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。

小结


  AFSecurityPolicy 同样也作为一个即插即用的模块，在 AFNetworking 中作为验证 HTTPS 证书是否有效的模块存在，在 iOS 对 HTTPS 日渐重视的今天，在我看来，使用 HTTPS 会成为今后 API 开发的标配。


相关文章

关于其他 AFNetworking 源代码分析的其他文章：


  AFNetworking 概述（一）
  AFNetworking 的核心 AFURLSessionManager（二）
  处理请求和响应 AFURLSerialization（三）
  AFNetworkReachabilityManager 监控网络状态（四）
  验证 HTTPS 请求的证书（五）




Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>AFNetworkReachabilityManager 监控网络状态（四）</title>
      <url>/ios/2016/12/06/AFNetworkReachabilityManager-%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81-%E5%9B%9B/</url>
      <content type="text">
  文章来自AFNetworkReachabilityManager 监控网络状态（四）



  作者Blog: Draveness


AFNetworkReachabilityManager 是对 SystemConfiguration 模块的封装，苹果的文档中也有一个类似的项目 Reachability 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。

同样在 github 上有一个类似的项目叫做 Reachability 不过这个项目由于命名的原因可能会在审核时被拒绝。

无论是 AFNetworkReachabilityManager，苹果官方的项目或者说 github 上的 Reachability，它们的实现都是类似的，而在这里我们会以 AFNetworking 中的 AFNetworkReachabilityManager 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。

AFNetworkReachabilityManager 的使用和实现

AFNetworkReachabilityManager 的使用还是非常简单的，只需要三个步骤，就基本可以完成对网络状态的监控。


  初始化 AFNetworkReachabilityManager
  调用 startMonitoring 方法开始对网络状态进行监控
  设置 networkReachabilityStatusBlock 在每次网络状态改变时, 调用这个 block


初始化 AFNetworkReachabilityManager

在初始化方法中，使用 SCNetworkReachabilityCreateWithAddress 或者 SCNetworkReachabilityCreateWithName 生成一个 SCNetworkReachabilityRef 的引用。

+ (instancetype)managerForDomain:(NSString *)domain {
    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);

    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];

    return manager;
}

+ (instancetype)managerForAddress:(const void *)address {
    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);
    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];

    return manager;
}



  这两个方法会通过一个域名或者一个 sockaddr_in 的指针生成一个 SCNetworkReachabilityRef
  调用 - [AFNetworkReachabilityManager initWithReachability:] 将生成的 SCNetworkReachabilityRef 引用传给 networkReachability
  设置一个默认的 networkReachabilityStatus


- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.networkReachability = CFBridgingRelease(reachability);
    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;

    return self;
}



  当调用 CFBridgingRelease(reachability) 后，会把 reachability 桥接成一个 NSObject 对象赋值给 self.networkReachability，然后释放原来的 CoreFoundation 对象。


监控网络状态

在初始化 AFNetworkReachabilityManager 后，会调用 startMonitoring 方法开始监控网络状态。

- (void)startMonitoring {
    [self stopMonitoring];

    if (!self.networkReachability) {
        return;
    }

    __weak __typeof(self)weakSelf = self;
    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
        __strong __typeof(weakSelf)strongSelf = weakSelf;

        strongSelf.networkReachabilityStatus = status;
        if (strongSelf.networkReachabilityStatusBlock) {
            strongSelf.networkReachabilityStatusBlock(status);
        }

    };

    id networkReachability = self.networkReachability;
    SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};
    SCNetworkReachabilitySetCallback((__bridge SCNetworkReachabilityRef)networkReachability, AFNetworkReachabilityCallback, &amp;amp;context);
    SCNetworkReachabilityScheduleWithRunLoop((__bridge SCNetworkReachabilityRef)networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
        SCNetworkReachabilityFlags flags;
        if (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;amp;flags)) {
            AFPostReachabilityStatusChange(flags, callback);
        }
    });
}



  
    先调用 - stopMonitoring 方法，如果之前设置过对网络状态的监听，使用 SCNetworkReachabilityUnscheduleFromRunLoop 方法取消之前在 Main Runloop 中的监听

     - (void)stopMonitoring {
     if (!self.networkReachability) {
         return;
     }
	
     SCNetworkReachabilityUnscheduleFromRunLoop((__bridge SCNetworkReachabilityRef)self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);
 }

    
  
  
    创建一个在每次网络状态改变时的回调

     __weak __typeof(self)weakSelf = self;
 AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
     __strong __typeof(weakSelf)strongSelf = weakSelf;
	
     strongSelf.networkReachabilityStatus = status;
     if (strongSelf.networkReachabilityStatusBlock) {
         strongSelf.networkReachabilityStatusBlock(status);
     }
	
 };

    

    
      每次回调被调用时
        
          重新设置 networkReachabilityStatus 属性
          调用 networkReachabilityStatusBlock
        
      
    
  
  
    创建一个 SCNetworkReachabilityContext

     typedef struct {
     CFIndex		version;
     void *		__nullable info;
     const void	* __nonnull (* __nullable retain)(const void *info);
     void		(* __nullable release)(const void *info);
     CFStringRef	__nonnull (* __nullable copyDescription)(const void *info);
 } SCNetworkReachabilityContext;
	
 SCNetworkReachabilityContext context = {
     0,
     (__bridge void *)callback,
     AFNetworkReachabilityRetainCallback, 
     AFNetworkReachabilityReleaseCallback, 
     NULL
 };

    

    
      其中的 callback 就是上一步中的创建的 block 对象
      这里的 AFNetworkReachabilityRetainCallback 和 AFNetworkReachabilityReleaseCallback 都是非常简单的 block，在回调被调用时，只是使用 Block_copy 和 Block_release 这样的宏
      
        传入的 info 会以参数的形式在 AFNetworkReachabilityCallback 执行时传入

        static const void * AFNetworkReachabilityRetainCallback(const void *info) {
      return Block_copy(info);
  }

        static void AFNetworkReachabilityReleaseCallback(const void *info) {
      if (info) {
          Block_release(info);
      }
  }
      
    
  
  
    当目标的网络状态改变时，会调用传入的回调

     SCNetworkReachabilitySetCallback(
     (__bridge SCNetworkReachabilityRef)networkReachability,
     AFNetworkReachabilityCallback, 
     &amp;amp;context
 );

    
  
  
    在 Main Runloop 中对应的模式开始监控网络状态

     SCNetworkReachabilityScheduleWithRunLoop(
     (__bridge SCNetworkReachabilityRef)networkReachability, 
     CFRunLoopGetMain(), 
     kCFRunLoopCommonModes
 );

    
  
  
    获取当前的网络状态，调用 callback

     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
     SCNetworkReachabilityFlags flags;
     if (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;amp;flags)) {
         AFPostReachabilityStatusChange(flags, callback);
     }
 });

    
  


在下一节中会介绍上面所提到的一些 C 函数以及各种回调。

设置 networkReachabilityStatusBlock 以及回调

在 Main Runloop 中对网络状态进行监控之后，在每次网络状态改变，就会调用 AFNetworkReachabilityCallback 函数：

static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) {
    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);
}


这里会从 info 中取出之前存在 context 中的 AFNetworkReachabilityStatusBlock。

__weak __typeof(self)weakSelf = self;
AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
    __strong __typeof(weakSelf)strongSelf = weakSelf;

    strongSelf.networkReachabilityStatus = status;
    if (strongSelf.networkReachabilityStatusBlock) {
        strongSelf.networkReachabilityStatusBlock(status);
    }

};


取出这个 block 之后，传入 AFPostReachabilityStatusChange 函数：

static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) {
    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);
    dispatch_async(dispatch_get_main_queue(), ^{
        if (block) {
            block(status);
        }
        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
        NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) };
        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];
    });
}



  调用 AFNetworkReachabilityStatusForFlags 获取当前的网络可达性状态
  在主线程中异步执行上面传入的 callback block（设置 self 的网络状态，调用 networkReachabilityStatusBlock）
  发送 AFNetworkingReachabilityDidChangeNotification 通知.


static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {
    BOOL isReachable = ((flags &amp;amp; kSCNetworkReachabilityFlagsReachable) != 0);
    BOOL needsConnection = ((flags &amp;amp; kSCNetworkReachabilityFlagsConnectionRequired) != 0);
    BOOL canConnectionAutomatically = (((flags &amp;amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags &amp;amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));
    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;amp;&amp;amp; (flags &amp;amp; kSCNetworkReachabilityFlagsInterventionRequired) == 0);
    BOOL isNetworkReachable = (isReachable &amp;amp;&amp;amp; (!needsConnection || canConnectWithoutUserInteraction));

    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;
    if (isNetworkReachable == NO) {
        status = AFNetworkReachabilityStatusNotReachable;
    }
#if	TARGET_OS_IPHONE
    else if ((flags &amp;amp; kSCNetworkReachabilityFlagsIsWWAN) != 0) {
        status = AFNetworkReachabilityStatusReachableViaWWAN;
    }
#endif
    else {
        status = AFNetworkReachabilityStatusReachableViaWiFi;
    }

    return status;
}


因为 flags 是一个 SCNetworkReachabilityFlags，它的不同位代表了不同的网络可达性状态，通过 flags 的位操作，获取当前的状态信息 AFNetworkReachabilityStatus。

typedef CF_OPTIONS(uint32_t, SCNetworkReachabilityFlags) {
	kSCNetworkReachabilityFlagsTransientConnection	= 1&amp;lt;&amp;lt;0,
	kSCNetworkReachabilityFlagsReachable		= 1&amp;lt;&amp;lt;1,
	kSCNetworkReachabilityFlagsConnectionRequired	= 1&amp;lt;&amp;lt;2,
	kSCNetworkReachabilityFlagsConnectionOnTraffic	= 1&amp;lt;&amp;lt;3,
	kSCNetworkReachabilityFlagsInterventionRequired	= 1&amp;lt;&amp;lt;4,
	kSCNetworkReachabilityFlagsConnectionOnDemand	= 1&amp;lt;&amp;lt;5,	// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)
	kSCNetworkReachabilityFlagsIsLocalAddress	= 1&amp;lt;&amp;lt;16,
	kSCNetworkReachabilityFlagsIsDirect		= 1&amp;lt;&amp;lt;17,
#if	TARGET_OS_IPHONE
	kSCNetworkReachabilityFlagsIsWWAN		= 1&amp;lt;&amp;lt;18,
#endif	// TARGET_OS_IPHONE

	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic
};


这里就是在 SystemConfiguration 中定义的全部的网络状态的标志位。

与 AFNetworking 协作

其实这个类与 AFNetworking 整个框架并没有太多的耦合。正相反，它在整个框架中作为一个即插即用的类使用，每一个 AFURLSessionManager 都会持有一个 AFNetworkReachabilityManager 的实例。

self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];


这是整个框架中除了 AFNetworkReachabilityManager.h/m 文件，唯一一个引用到这个类的地方。

在实际的使用中，我们也可以直接操作 AFURLSessionManager 的 reachabilityManager 来获取当前的网络可达性状态，而不是自己手动初始化一个实例，当然这么做也是没有任何问题的。

总结


  AFNetworkReachabilityManager 实际上只是一个对底层 SystemConfiguration 库中的 C 函数封装的类，它为我们隐藏了 C 语言的实现，提供了统一的 Objective-C 语言接口
  它是 AFNetworking 中一个即插即用的模块


相关文章

关于其他 AFNetworking 源代码分析的其他文章：


  AFNetworking 概述（一）
  AFNetworking 的核心 AFURLSessionManager（二）
  处理请求和响应 AFURLSerialization（三）
  AFNetworkReachabilityManager 监控网络状态（四）
  验证 HTTPS 请求的证书（五）


Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>处理请求和响应 AFURLSerialization（三）</title>
      <url>/ios/2016/12/05/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94-AFURLSerialization-%E4%B8%89/</url>
      <content type="text">
  文章来自处理请求和响应 AFURLSerialization（三）



  作者Blog: Draveness


在前面两个部分已经分析过 AFNetworking 是对 NSURLSession 的封装，也了解了它是如何发出请求的，在这里我们对发出请求以及接收响应的过程进行序列化，这涉及到两个模块：


  AFURLResponseSerialization
  AFURLRequestSerialization


前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。

我们首先会对 AFURLResponseSerialization 进行简单的介绍，因为这个模块使用在 AFURLSessionManager 也就是核心类中，而后者 AFURLRequestSerialization 主要用于 AFHTTPSessionManager 中，因为它主要用于修改 HTTP 头部。

AFURLResponseSerialization

其实在整个 AFNetworking 项目中并不存在 AFURLResponseSerialization 这个类，这只是一个协议，遵循这个协议的类会将数据解码成更有意义的表现形式。

协议的内容也非常简单，只有一个必须实现的方法。

@protocol AFURLResponseSerialization &amp;lt;NSObject, NSSecureCoding, NSCopying&amp;gt;

- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response
                           data:(nullable NSData *)data
                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;

@end


遵循这个协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，实现安全编码、拷贝以及 Objective-C 对象的基本行为。

仅看 AFURLResponseSerialization 协议对类的要求还是十分的简单，返回对特定响应的数据解码后的对象.

在具体了解模块中类的实现之前，先看一下这个小模块的结构：




  模块中的所有类都遵循 AFURLResponseSerialization 协议
  AFHTTPResponseSerializer 为模块中最终要的根类


AFHTTPResponseSerializer

下面我们对模块中最重要的根类的实现进行分析，也就是 AFHTTPResponseSerializer。它是在 AFURLResponseSerialization 模块中最基本的类（因为 AFURLResponseSerialization 只是一个协议）

初始化

首先是这个类的实例化方法：

+ (instancetype)serializer {
    return [[self alloc] init];
}

- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.stringEncoding = NSUTF8StringEncoding;

    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    self.acceptableContentTypes = nil;

    return self;
}


因为是对 HTTP 响应进行序列化，所以这里设置了 stringEncoding 为 NSUTF8StringEncoding 而且没有对接收的内容类型加以限制。

将 acceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。

验证响应的有效性

AFHTTPResponseSerializer 中方法的实现最长，并且最重要的就是 - [AFHTTPResponseSerializer validateResponse:data:error:]

- (BOOL)validateResponse:(NSHTTPURLResponse *)response
                    data:(NSData *)data
                   error:(NSError * __autoreleasing *)error
{
    BOOL responseIsValid = YES;
    NSError *validationError = nil;

    if (response &amp;amp;&amp;amp; [response isKindOfClass:[NSHTTPURLResponse class]]) {
        if (self.acceptableContentTypes &amp;amp;&amp;amp; ![self.acceptableContentTypes containsObject:[response MIMEType]]) {
			#1: 返回内容类型无效
        }

        if (self.acceptableStatusCodes &amp;amp;&amp;amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;amp;&amp;amp; [response URL]) {
			#2: 返回状态码无效
        }
    }

    if (error &amp;amp;&amp;amp; !responseIsValid) {
        *error = validationError;
    }

    return responseIsValid;
}


这个方法根据在初始化方法中初始化的属性 acceptableContentTypes 和 acceptableStatusCodes 来判断当前响应是否有效。

if ([data length] &amp;gt; 0 &amp;amp;&amp;amp; [response URL]) {
    NSMutableDictionary *mutableUserInfo = [@{
                                              NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],
                                              NSURLErrorFailingURLErrorKey:[response URL],
                                              AFNetworkingOperationFailingURLResponseErrorKey: response,
                                            } mutableCopy];
    if (data) {
        mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
    }

    validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
}

responseIsValid = NO;


其中第一、二部分的代码非常相似，出现错误时通过 AFErrorWithUnderlyingError 生成格式化之后的错误，最后设置 responseIsValid。

NSMutableDictionary *mutableUserInfo = [@{
                                   NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                   NSURLErrorFailingURLErrorKey:[response URL],
                                   AFNetworkingOperationFailingURLResponseErrorKey: response,
                           } mutableCopy];

if (data) {
    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
}

validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);

responseIsValid = NO;


第二部分的代码就不说了，实现上都是差不多的。

协议的实现

首先是对 AFURLResponseSerialization 协议的实现

- (id)responseObjectForResponse:(NSURLResponse *)response
                           data:(NSData *)data
                          error:(NSError *__autoreleasing *)error
{
    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];

    return data;
}


调用上面的方法对响应进行验证，然后返回数据，实在是没什么难度。

之后对 NSSecureCoding 还有 NSCopying 协议的实现也都是大同小异，跟我们实现这些协议没什么区别，更没什么值得看的地方。

AFJSONResponseSerializer

接下来，看一下 AFJSONResponseSerializer 这个继承自 AFHTTPResponseSerializer 类的实现。

初始化方法只是在调用父类的初始化方法之后更新了 acceptableContentTypes 属性：

- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];

    return self;
}


协议的实现

这个类中与父类差别最大的就是对 AFURLResponseSerialization 协议的实现。

- (id)responseObjectForResponse:(NSURLResponse *)response
                           data:(NSData *)data
                          error:(NSError *__autoreleasing *)error
{
	#1: 验证请求

	#2: 解决一个由只包含一个空格的响应引起的 bug, 略

	#3: 序列化 JSON
	
	#4: 移除 JSON 中的 null

    if (error) {
        *error = AFErrorWithUnderlyingError(serializationError, *error);
    }

    return responseObject;
}



  
    验证请求的有效性

     NSStringEncoding stringEncoding = self.stringEncoding;
 if (response.textEncodingName) {
     CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName);
     if (encoding != kCFStringEncodingInvalidId) {
         stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);
     }
 }

  
  解决一个空格引起的 bug
  
    序列化 JSON

     id responseObject = nil;
 NSError *serializationError = nil;
 @autoreleasepool {
     NSString *responseString = [[NSString alloc] initWithData:data encoding:stringEncoding];
     if (responseString &amp;amp;&amp;amp; ![responseString isEqualToString:@&quot; &quot;]) {
         // Workaround for a bug in NSJSONSerialization when Unicode character escape codes are used instead of the actual character
         // See http://stackoverflow.com/a/12843465/157142
         data = [responseString dataUsingEncoding:NSUTF8StringEncoding];
	
         if (data) {
             if ([data length] &amp;gt; 0) {
                 responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;amp;serializationError];
             } else {
                 return nil;
             }
         } else {
             NSDictionary *userInfo = @{
                                        NSLocalizedDescriptionKey: NSLocalizedStringFromTable(@&quot;Data failed decoding as a UTF-8 string&quot;, @&quot;AFNetworking&quot;, nil),
                                        NSLocalizedFailureReasonErrorKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Could not decode string: %@&quot;, @&quot;AFNetworking&quot;, nil), responseString]
                                        };
	
             serializationError = [NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo];
         }
     }
 }

  
  
    移除 JSON 中的 null

     if (self.removesKeysWithNullValues &amp;amp;&amp;amp; responseObject) {
     responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
 }

  


其中移除 JSON 中 null 的函数 AFJSONObjectByRemovingKeysWithNullValues 是一个递归调用的函数：

static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {
    if ([JSONObject isKindOfClass:[NSArray class]]) {
        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        for (id value in (NSArray *)JSONObject) {
            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
        }

        return (readingOptions &amp;amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        for (id &amp;lt;NSCopying&amp;gt; key in [(NSDictionary *)JSONObject allKeys]) {
            id value = (NSDictionary *)JSONObject[key];
            if (!value || [value isEqual:[NSNull null]]) {
                [mutableDictionary removeObjectForKey:key];
            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);
            }
        }

        return (readingOptions &amp;amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
    }

    return JSONObject;
}


其中移除 null 靠的就是 [mutableDictionary removeObjectForKey:key] 这一行代码。

AFURLRequestSerialization

AFURLRequestSerialization 的主要工作是对发出的 HTTP 请求进行处理，它有几部分的工作需要完成。

而这个文件中的大部分类都是为 AFHTTPRequestSerializer 服务的：


  处理查询的 URL 参数
  设置 HTTP 头部字段
  设置请求的属性
  分块上传



  这篇文章不会对其中涉及分块上传的部分进行分析，因为其中涉及到了多个类的功能，比较复杂，如果有兴趣可以研究一下。


处理查询参数

处理查询参数这部分主要是通过 AFQueryStringPair 还有一些 C 函数来完成的，这个类有两个属性 field 和 value 对应 HTTP 请求的查询 URL 中的参数。

@interface AFQueryStringPair : NSObject
@property (readwrite, nonatomic, strong) id field;
@property (readwrite, nonatomic, strong) id value;

- (instancetype)initWithField:(id)field value:(id)value;

- (NSString *)URLEncodedStringValue;
@end


初始化方法也不必多看，其中的 - [AFQueryStringPair URLEncodedStringValue] 方法会返回 key=value 这种格式，同时使用 AFPercentEscapedStringFromString 函数来对 field 和 value 进行处理，将其中的 :#[]@!$&amp;amp;'()*+,;= 等字符转换为百分号表示的形式。

这一部分代码还负责返回查询参数，将 AFQueryStringPair 或者 key value 转换为以下这种形式：

username=dravenss&amp;amp;password=123456&amp;amp;hello[world]=helloworld



它的实现主要依赖于一个递归函数 AFQueryStringPairsFromKeyAndValue，如果当前的 value 是一个集合类型的话，那么它就会不断地递归调用自己。

NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) {
    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];

    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];

    if ([value isKindOfClass:[NSDictionary class]]) {
        NSDictionary *dictionary = value;
        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries
        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
            id nestedValue = dictionary[nestedKey];
            if (nestedValue) {
                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];
            }
        }
    } else if ([value isKindOfClass:[NSArray class]]) {
        NSArray *array = value;
        for (id nestedValue in array) {
            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];
        }
    } else if ([value isKindOfClass:[NSSet class]]) {
        NSSet *set = value;
        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) {
            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];
        }
    } else {
        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];
    }

    return mutableQueryStringComponents;
}


最后返回一个数组

[
	username=draveness,
	password=123456,
	hello[world]=helloworld
]


得到这个数组之后就会调用 AFQueryStringFromParameters 使用 &amp;amp; 来拼接它们。

static NSString * AFQueryStringFromParameters(NSDictionary *parameters) {
    NSMutableArray *mutablePairs = [NSMutableArray array];
    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {
        [mutablePairs addObject:[pair URLEncodedStringValue]];
    }

    return [mutablePairs componentsJoinedByString:@&quot;&amp;amp;&quot;];
}


设置 HTTP 头部字段

AFHTTPRequestSerializer 在头文件中提供了一些属性方便我们设置 HTTP 头部字段。同时，在类的内部，它提供了 - [AFHTTPRequestSerializer setValue:forHTTPHeaderField:] 方法来设置 HTTP 头部，其实它的实现都是基于一个名为 mutableHTTPRequestHeaders 的属性的：

- (void)setValue:(NSString *)value
forHTTPHeaderField:(NSString *)field
{
	[self.mutableHTTPRequestHeaders setValue:value forKey:field];
}

- (NSString *)valueForHTTPHeaderField:(NSString *)field {
    return [self.mutableHTTPRequestHeaders valueForKey:field];
}


在设置 HTTP 头部字段时，都会存储到这个可变字典中。而当真正使用时，会用 HTTPRequestHeaders 这个方法，来获取对应版本的不可变字典。

- (NSDictionary *)HTTPRequestHeaders {
    return [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];
}


到了这里，可以来分析一下，这个类是如何设置一些我们平时常用的头部字段的。首先是 User-Agent，在 AFHTTPRequestSerializer 刚刚初始化时，就会根据当前编译的平台生成一个 userAgent 字符串：

userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];

[self setValue:userAgent forHTTPHeaderField:@&quot;User-Agent&quot;];


设置验证字段时，可以使用 - [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:] 方法

- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
                                       password:(NSString *)password
{
    NSData *basicAuthCredentials = [[NSString stringWithFormat:@&quot;%@:%@&quot;, username, password] dataUsingEncoding:NSUTF8StringEncoding];
    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
    [self setValue:[NSString stringWithFormat:@&quot;Basic %@&quot;, base64AuthCredentials] forHTTPHeaderField:@&quot;Authorization&quot;];
}


设置请求的属性

还有一写 NSURLRequest 的属性是通过另一种方式来设置的，AFNetworking 为这些功能提供了接口

@property (nonatomic, assign) BOOL allowsCellularAccess;

@property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;

@property (nonatomic, assign) BOOL HTTPShouldHandleCookies;

@property (nonatomic, assign) BOOL HTTPShouldUsePipelining;

@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;

@property (nonatomic, assign) NSTimeInterval timeoutInterval;


它们都会通过 AFHTTPRequestSerializerObservedKeyPaths 的调用而返回。

static NSArray * AFHTTPRequestSerializerObservedKeyPaths() {
    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];
    });

    return _AFHTTPRequestSerializerObservedKeyPaths;
}


在这些属性被设置时，会触发 KVO，然后将新的属性存储在一个名为 mutableObservedChangedKeyPaths 的字典中：

- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(__unused id)object
                        change:(NSDictionary *)change
                       context:(void *)context
{
    if (context == AFHTTPRequestSerializerObserverContext) {
        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) {
            [self.mutableObservedChangedKeyPaths removeObject:keyPath];
        } else {
            [self.mutableObservedChangedKeyPaths addObject:keyPath];
        }
    }
}


然后会在生成 NSURLRequest 的时候设置这些属性。

NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
mutableRequest.HTTPMethod = method;

for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
    if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
        [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
    }
}


关于这个方法的的具体实现会在下一节中介绍。

工作流程

AFHTTPRequestSerializer 会在 AHHTTPSessionManager 初始化时一并初始化，这时它会根据当前系统环境预设置一些 HTTP 头部字段 Accept-Language User-Agent。

- (instancetype)init {
    self = [super init];
    if (!self) {
        return nil;
    }

    self.stringEncoding = NSUTF8StringEncoding;

    self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary];


	#1: 设置接收语言，用户代理，略

    // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
    self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil];

    self.mutableObservedChangedKeyPaths = [NSMutableSet set];
    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) {
            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];
        }
    }

    return self;
}


同时它还对一些属性进行 KVO，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。

在初始化之后，如果调用了 - [AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]，就会进入 AFHTTPRequestSerializer 的这一方法：


- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                                 URLString:(NSString *)URLString
                                parameters:(id)parameters
                                     error:(NSError *__autoreleasing *)error
{
    NSParameterAssert(method);
    NSParameterAssert(URLString);

    NSURL *url = [NSURL URLWithString:URLString];

    NSParameterAssert(url);

    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
    mutableRequest.HTTPMethod = method;

    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
        }
    }

    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];

	return mutableRequest;
}



  对参数进行检查
  
    设置 HTTP 方法

     mutableRequest.HTTPMethod = method;

  
  
    通过 mutableObservedChangedKeyPaths 字典设置 NSMutableURLRequest 的属性

     for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
     if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
         [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
     }
 }

  
  调用 - [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:] 设置 HTTP 头部字段和查询参数。


- [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:] 方法主要做了两件事情

- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request
                               withParameters:(id)parameters
                                        error:(NSError *__autoreleasing *)error
{
    NSParameterAssert(request);

    NSMutableURLRequest *mutableRequest = [request mutableCopy];

    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
        if (![request valueForHTTPHeaderField:field]) {
            [mutableRequest setValue:value forHTTPHeaderField:field];
        }
    }];

    NSString *query = nil;
    if (parameters) {
        if (self.queryStringSerialization) {
            NSError *serializationError;
            query = self.queryStringSerialization(request, parameters, &amp;amp;serializationError);

            if (serializationError) {
                if (error) {
                    *error = serializationError;
                }

                return nil;
            }
        } else {
            switch (self.queryStringSerializationStyle) {
                case AFHTTPRequestQueryStringDefaultStyle:
                    query = AFQueryStringFromParameters(parameters);
                    break;
            }
        }
    }

    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
        if (query) {
            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;amp;%@&quot; : @&quot;?%@&quot;, query]];
        }
    } else {
        // #2864: an empty string is a valid x-www-form-urlencoded payload
        if (!query) {
            query = @&quot;&quot;;
        }
        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) {
            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
        }
        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
    }

    return mutableRequest;
}



  
    通过 HTTPRequestHeaders 字典设置头部字段

     [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
     if (![request valueForHTTPHeaderField:field]) {
         [mutableRequest setValue:value forHTTPHeaderField:field];
     }
 }];

  
  
    调用 AFQueryStringFromParameters 将参数转换为查询参数

     query = AFQueryStringFromParameters(parameters);

  
  
    将 parameters 添加到 URL 或者 HTTP body 中

     if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
     if (query) {
         mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;amp;%@&quot; : @&quot;?%@&quot;, query]];
     }
 } else {
     // #2864: an empty string is a valid x-www-form-urlencoded payload
     if (!query) {
         query = @&quot;&quot;;
     }
     if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) {
         [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
     }
     [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
 }


    
      如果 HTTP 方法为 GET HEAD 或者 DELETE，也就是在初始化方法中设置的，那么参数会追加到 URL 后面。否则会被放入 HTTP body 中。
    
  
  
    最后这个方法会返回一个 NSMutableURLRequest
  


小结


  AFURLResponseSerialization 负责对返回的数据进行序列化
  AFURLRequestSerialization 负责生成 NSMutableURLRequest，为请求设置 HTTP 头部，管理发出的请求


相关文章

关于其他 AFNetworking 源代码分析的其他文章：


  AFNetworking 概述（一）
  AFNetworking 的核心 AFURLSessionManager（二）
  处理请求和响应 AFURLSerialization（三）
  AFNetworkReachabilityManager 监控网络状态（四）
  验证 HTTPS 请求的证书（五）




Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>AFNetworking 的核心 AFURLSessionManager（二）</title>
      <url>/ios/2016/12/03/AFNetworking-%E7%9A%84%E6%A0%B8%E5%BF%83-AFURLSessionManager-%E4%BA%8C/</url>
      <content type="text">
  文章来自AFNetworking 的核心 AFURLSessionManager（二）


AFURLSessionManager 绝对可以称得上是 AFNetworking 的核心。


  负责创建和管理 NSURLSession
  管理 NSURLSessionTask
  实现 NSURLSessionDelegate 等协议中的代理方法
  使用 AFURLSessionManagerTaskDelegate 管理进度
  使用 _AFURLSessionTaskSwizzling 调剂方法
  引入 AFSecurityPolicy 保证请求的安全
  引入 AFNetworkReachabilityManager 监控网络状态


我们会在这里着重介绍上面七个功能中的前五个，分析它是如何包装 NSURLSession 以及众多代理方法的。

创建和管理 NSURLSession

在使用 AFURLSessionManager 时，第一件要做的事情一定是初始化：

- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    self.operationQueue.maxConcurrentOperationCount = 1;

    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    self.responseSerializer = [AFJSONResponseSerializer serializer];

    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];

    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;
    
    #1: 为已有的 task 设置代理, 略

    return self;
}


在初始化方法中，需要完成初始化一些自己持有的实例：


  初始化会话配置（NSURLSessionConfiguration），默认为 defaultSessionConfiguration
  初始化会话（session），并设置会话的代理以及代理队列
  初始化管理响应序列化（AFJSONResponseSerializer），安全认证（AFSecurityPolicy）以及监控网络状态（AFNetworkReachabilityManager）的实例
  初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）


管理 NSURLSessionTask

接下来，在获得了 AFURLSessionManager 的实例之后，我们可以通过以下方法创建 NSURLSessionDataTask 的实例：

- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;

- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request
                                         fromFile:(NSURL *)fileURL
                                         progress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;

...

- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request
                                             progress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;

...



这里省略了一些返回 NSURLSessionTask 的方法，因为这些接口的形式都是差不多的。

&amp;lt;/id&amp;gt;我们将以 - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] 方法的实现为例，分析它是如何实例化并返回一个 NSURLSessionTask 的实例的：

- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

    __block NSURLSessionDataTask *dataTask = nil;
    url_session_manager_create_task_safely(^{
        dataTask = [self.session dataTaskWithRequest:request];
    });

    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

    return dataTask;
}



  url_session_manager_create_task_safely 的调用是因为苹果框架中的一个 bug #2093，如果有兴趣可以看一下，在这里就不说明了



  调用 - [NSURLSession dataTaskWithRequest:] 方法传入 NSURLRequest
  调用 - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:] 方法返回一个 AFURLSessionManagerTaskDelegate 对象
  将 completionHandler uploadProgressBlock 和 downloadProgressBlock 传入该对象并在相应事件发生时进行回调


- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
    delegate.manager = self;
    delegate.completionHandler = completionHandler;

    dataTask.taskDescription = self.taskDescriptionForSessionTasks;
    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}


在这个方法中同时调用了另一个方法 - [AFURLSessionManager setDelegate:forTask:] 来设置代理：

- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
		
	#1: 检查参数, 略

    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    [delegate setupProgressForTask:task];
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}


正如上面所提到的，AFURLSessionManager 就是通过字典 mutableTaskDelegatesKeyedByTaskIdentifier 来存储并管理每一个 NSURLSessionTask，它以 taskIdentifier 为键存储 task。

该方法使用 NSLock 来保证不同线程使用 mutableTaskDelegatesKeyedByTaskIdentifier 时，不会出现线程竞争的问题。

同时调用 - setupProgressForTask:，我们会在下面具体介绍这个方法。

实现 NSURLSessionDelegate 等协议中的代理方法

在 AFURLSessionManager 的头文件中可以看到，它遵循了多个协议，其中包括：


  NSURLSessionDelegate
  NSURLSessionTaskDelegate
  NSURLSessionDataDelegate
  NSURLSessionDownloadDelegate


它在初始化方法 - [AFURLSessionManager initWithSessionConfiguration:] 将 NSURLSession 的代理指向 self，然后实现这些方法，提供更简洁的 block 的接口：

- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;
- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;
...


它为所有的代理协议都提供了对应的 block 接口，方法实现的思路都是相似的，我们以 - [AFNRLSessionManager setSessionDidBecomeInvalidBlock:] 为例。

首先调用 setter 方法，将 block 存入 sessionDidBecomeInvalid 属性中：

- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block {
    self.sessionDidBecomeInvalid = block;
}


当代理方法调用时，如果存在对应的 block，会执行对应的 block：

- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error
{
    if (self.sessionDidBecomeInvalid) {
        self.sessionDidBecomeInvalid(session, error);
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
}


其他相似的接口实现也都差不多，这里直接跳过了。

使用 AFURLSessionManagerTaskDelegate 管理进度

在上面我们提到过 AFURLSessionManagerTaskDelegate 类，它主要为 task 提供进度管理功能，并在 task 结束时回调， 也就是调用在 - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] 等方法中传入的 completionHandler。

我们首先分析一下 AFURLSessionManagerTaskDelegate 是如何对进度进行跟踪的：

- (void)setupProgressForTask:(NSURLSessionTask *)task {

	#1：设置在上传进度或者下载进度状态改变时的回调
	
	#2：KVO

}


该方法的实现有两个部分，一部分是对代理持有的两个属性 uploadProgress 和 downloadProgress 设置回调

__weak __typeof__(task) weakTask = task;

self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;
[self.uploadProgress setCancellable:YES];
[self.uploadProgress setCancellationHandler:^{
   __typeof__(weakTask) strongTask = weakTask;
   [strongTask cancel];
}];
[self.uploadProgress setPausable:YES];
[self.uploadProgress setPausingHandler:^{
   __typeof__(weakTask) strongTask = weakTask;
   [strongTask suspend];
}];
if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) {
   [self.uploadProgress setResumingHandler:^{
       __typeof__(weakTask) strongTask = weakTask;
       [strongTask resume];
   }];
}


这里只有对 uploadProgress 设置回调的代码，设置 downloadProgress 与这里完全相同


  主要目的是在对应 NSProgress 的状态改变时，调用 resume suspend 等方法改变 task 的状态。


第二部分是对 task 和 NSProgress 属性进行键值观测：

[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))
         options:NSKeyValueObservingOptionNew
         context:NULL];
[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))
         options:NSKeyValueObservingOptionNew
         context:NULL];

[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))
         options:NSKeyValueObservingOptionNew
         context:NULL];
[task addObserver:self
      forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))
         options:NSKeyValueObservingOptionNew
         context:NULL];

[self.downloadProgress addObserver:self
                       forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                          options:NSKeyValueObservingOptionNew
                          context:NULL];
[self.uploadProgress addObserver:self
                     forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                        options:NSKeyValueObservingOptionNew
                        context:NULL];


在 observeValueForKeypath:ofObject:change:context: 方法中改变进度，并调用 block

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSString *,id&amp;gt; *)change context:(void *)context {
    if ([object isKindOfClass:[NSURLSessionTask class]]) {
        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {
            self.downloadProgress.completedUnitCount = [change[@&quot;new&quot;] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) {
            self.downloadProgress.totalUnitCount = [change[@&quot;new&quot;] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {
            self.uploadProgress.completedUnitCount = [change[@&quot;new&quot;] longLongValue];
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) {
            self.uploadProgress.totalUnitCount = [change[@&quot;new&quot;] longLongValue];
        }
    }
    else if ([object isEqual:self.downloadProgress]) {
        if (self.downloadProgressBlock) {
            self.downloadProgressBlock(object);
        }
    }
    else if ([object isEqual:self.uploadProgress]) {
        if (self.uploadProgressBlock) {
            self.uploadProgressBlock(object);
        }
    }
}


对象的某些属性改变时更新 NSProgress 对象或使用 block 传递 NSProgress 对象 self.uploadProgressBlock(object)。

代理方法 URLSession:task:didCompleteWithError:

在每一个 NSURLSessionTask 结束时，都会在代理方法 URLSession:task:didCompleteWithError: 中：


  调用传入的 completionHander block
  发出 AFNetworkingTaskDidCompleteNotification 通知


- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{
    #1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`

    if (error) {
    	#2：在存在错误时调用 `completionHandler`
    } else {
		#3：调用 `completionHandler`
    }
}


这是整个代理方法的骨架，先看一下最简单的第一部分代码：

__block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;

//Performance Improvement from #2672
NSData *data = nil;
if (self.mutableData) {
   data = [self.mutableData copy];
   //We no longer need the reference, so nil it out to gain back some memory.
   self.mutableData = nil;
}

if (self.downloadFileURL) {
   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
} else if (data) {
   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
}


这部分代码从 mutableData 中取出了数据，设置了 userInfo。

userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
    if (self.completionHandler) {
        self.completionHandler(task.response, responseObject, error);
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
    });
});


如果当前 manager 持有 completionGroup 或者 completionQueue 就使用它们。否则会创建一个 dispatch_group_t 并在主线程中调用 completionHandler 并发送通知(在主线程中)。

如果在执行当前 task 时没有遇到错误，那么先对数据进行序列化，然后同样调用 block 并发送通知。

dispatch_async(url_session_manager_processing_queue(), ^{
    NSError *serializationError = nil;
    responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;amp;serializationError];

    if (self.downloadFileURL) {
        responseObject = self.downloadFileURL;
    }

    if (responseObject) {
        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
    }

    if (serializationError) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
    }

    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
        if (self.completionHandler) {
            self.completionHandler(task.response, responseObject, serializationError);
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
        });
    });
});


代理方法 URLSession:dataTask:didReceiveData: 和 - URLSession:downloadTask:didFinishDownloadingToURL:

这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 mutableData 追加数据和处理下载的文件：

- (void)URLSession:(__unused NSURLSession *)session
          dataTask:(__unused NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data
{
    [self.mutableData appendData:data];
}

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location
{
    NSError *fileManagerError = nil;
    self.downloadFileURL = nil;

    if (self.downloadTaskDidFinishDownloading) {
        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
        if (self.downloadFileURL) {
            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;amp;fileManagerError];

            if (fileManagerError) {
                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];
            }
        }
    }
}


使用 _AFURLSessionTaskSwizzling 调剂方法

_AFURLSessionTaskSwizzling 的唯一功能就是修改 NSURLSessionTask 的 resume 和 suspend 方法，使用下面的方法替换原有的实现

- (void)af_resume {
    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);
    NSURLSessionTaskState state = [self state];
    [self af_resume];
    
    if (state != NSURLSessionTaskStateRunning) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];
    }
}

- (void)af_suspend {
    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);
    NSURLSessionTaskState state = [self state];
    [self af_suspend];
    
    if (state != NSURLSessionTaskStateSuspended) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];
    }
}


这样做的目的是为了在方法 resume 或者 suspend 被调用时发出通知。

具体方法调剂的过程是在 + load 方法中进行的


  load 方法只会在整个文件被引入时调用一次


+ (void)load {
    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;
        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
#pragma clang diagnostic pop
        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
        Class currentClass = [localDataTask class];
        
        while (class_getInstanceMethod(currentClass, @selector(resume))) {
            Class superClass = [currentClass superclass];
            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
            if (classResumeIMP != superclassResumeIMP &amp;amp;&amp;amp;
                originalAFResumeIMP != classResumeIMP) {
                [self swizzleResumeAndSuspendMethodForClass:currentClass];
            }
            currentClass = [currentClass superclass];
        }
        
        [localDataTask cancel];
        [session finishTasksAndInvalidate];
    }
}



  首先用 NSClassFromString(@&quot;NSURLSessionTask&quot;) 判断当前部署的 iOS 版本是否含有类 NSURLSessionTask
  因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例
  取得当前类 _AFURLSessionTaskSwizzling 中的实现 af_resume
  如果当前类 currentClass 有 resume 方法
    
      真：5
      假：6
    
  
  使用 swizzleResumeAndSuspendMethodForClass: 调剂该类的 resume 和 suspend 方法
  currentClass = [currentClass superclass]



  这里复杂的实现是为了解决 bug #2702


引入 AFSecurityPolicy 保证请求的安全

AFSecurityPolicy 是 AFNetworking 用来保证 HTTP 请求安全的类，它被 AFURLSessionManager 持有，如果你在 AFURLSessionManager 的实现文件中搜索 self.securityPolicy，你只会得到三条结果：


  初始化 self.securityPolicy = [AFSecurityPolicy defaultPolicy]
  收到连接层的验证请求时
  任务接收到验证请求时


在 API 调用上，后两者都调用了 - [AFSecurityPolicy evaluateServerTrust:forDomain:] 方法来判断当前服务器是否被信任，我们会在接下来的文章中具体介绍这个方法的实现的作用。

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
{
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    __block NSURLCredential *credential = nil;

    if (self.taskDidReceiveAuthenticationChallenge) {
        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;amp;credential);
    } else {
        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                disposition = NSURLSessionAuthChallengeUseCredential;
                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
            } else {
                disposition = NSURLSessionAuthChallengeRejectProtectionSpace;
            }
        } else {
            disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        }
    }

    if (completionHandler) {
        completionHandler(disposition, credential);
    }
}


如果没有传入 taskDidReceiveAuthenticationChallenge block，只有在上述方法返回 YES 时，才会获得认证凭证 credential。

引入 AFNetworkReachabilityManager 监控网络状态

与 AFSecurityPolicy 相同，AFURLSessionManager 对网络状态的监控是由 AFNetworkReachabilityManager 来负责的，它仅仅是持有一个 AFNetworkReachabilityManager 的对象。


  真正需要判断网络状态时，仍然需要开发者调用对应的 API 获取网络状态。


小结


  AFURLSessionManager 是对 NSURLSession 的封装
  它通过 - [AFURLSessionManager dataTaskWithRequest:completionHandler:] 等接口创建 NSURLSessionDataTask 的实例
  持有一个字典 mutableTaskDelegatesKeyedByTaskIdentifier 管理这些 data task 实例
  引入 AFURLSessionManagerTaskDelegate 来对传入的 uploadProgressBlock downloadProgressBlock completionHandler 在合适的时间进行调用
  实现了全部的代理方法来提供 block 接口
  通过方法调剂在 data task 状态改变时，发出通知


相关文章

关于其他 AFNetworking 源代码分析的其他文章：


  AFNetworking 概述（一）
  AFNetworking 的核心 AFURLSessionManager（二）
  处理请求和响应 AFURLSerialization（三）
  AFNetworkReachabilityManager 监控网络状态（四）




Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>AFNetworking 概述（一）</title>
      <url>/ios/2016/12/01/AFNetworking-%E6%A6%82%E8%BF%B0-%E4%B8%80/</url>
      <content type="text">
  文章来自AFNetworking 概述（一）



  作者Blog: Draveness


在这一系列的文章中，我会对 AFNetworking 的源代码进行分析，深入了解一下它是如何构建的，如何在日常中完成发送 HTTP 请求、构建网络层这一任务。

AFNetworking 是如今 iOS 开发中不可缺少的组件之一。它的 github 配置上是如下介绍的：


  Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.


可以说使用 AFNetworking 的工程师构成的社区才使得它变得非常重要。

概述

我们今天是来深入研究一下这个与我们日常开发密切相关的框架是如何实现的。

这是我对 AFNetworking 整个架构的理解，随后一系列的文章也会逐步分析这些模块。



在这篇文章中，我们有两个问题需要了解：


  如何使用 NSURLSession 发出 HTTP 请求
  如何使用 AFNetworking 发出 HTTP 请求


NSURLSession

NSURLSession 以及与它相关的类为我们提供了下载内容的 API，这个 API 提供了一系列的代理方法来支持身份认证，并且支持后台下载。

使用 NSURLSession 来进行 HTTP 请求并且获得数据总共有五个步骤：


  实例化一个 NSURLRequest/NSMutableURLRequest，设置 URL
  通过 - sharedSession 方法获取 NSURLSession
  在 session 上调用 - dataTaskWithRequest:completionHandler: 方法返回一个 NSURLSessionDataTask
  向 data task 发送消息 - resume，开始执行这个任务
  在 completionHandler 中将数据编码，返回字符串


NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@&quot;https://github.com&quot;]];
NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *task = [session dataTaskWithRequest:request
                                       completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                           NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
                                           NSLog(@&quot;%@&quot;, dataStr);
                                       }];
[task resume];


这一段代码可以说是使用 NSURLSession 发送请求最简单的一段代码了，当你运行这段代码会在控制台看到一坨 github 首页的 html。

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; class=&quot;&quot;&amp;gt;
  &amp;lt;head prefix=&quot;og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#&quot;&amp;gt;
    &amp;lt;meta charset='utf-8'&amp;gt;
		...
	&amp;lt;/head&amp;gt;
	...
&amp;lt;/html&amp;gt;



AFNetworking

AFNetworking 的使用也是比较简单的，使用它来发出 HTTP 请求有两个步骤


  以服务器的主机地址或者域名生成一个 AFHTTPSessionManager 的实例
  调用 - GET:parameters:progress:success:failure: 方法


AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[NSURL alloc] initWithString:@&quot;hostname&quot;]];
[manager GET:@&quot;relative_url&quot; parameters:nil progress:nil
    success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@&quot;%@&quot; ,responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@&quot;%@&quot;, error);
    }];



  注意：在 iOS9 中，苹果默认全局 HTTPs，如果你要发送不安全的 HTTP 请求，需要在 info.plist 中加入如下键值对才能发出不安全的 HTTP 请求



  



  还有一件事情是要注意的是，AFNetworking 默认接收 json 格式的响应（因为这是在 iOS 平台上的框架，一般不需要 text/html），如果想要返回 html，需要设置 acceptableContentTypes


AFNetworking 的调用栈

在这一节中我们要分析一下在上面两个方法的调用栈，首先来看的是 AFHTTPSessionManager 的初始化方法 - initWithBaseURL:

- [AFHTTPSessionManager initWithBaseURL:]
	- [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]
		- [AFURLSessionManager initWithSessionConfiguration:]
			- [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]
			- [AFJSONResponseSerializer serializer] // 负责序列化响应
			- [AFSecurityPolicy defaultPolicy] // 负责身份认证
			- [AFNetworkReachabilityManager sharedManager] // 查看网络连接情况
		- [AFHTTPRequestSerializer serializer] // 负责序列化请求
		- [AFJSONResponseSerializer serializer] // 负责序列化响应


从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：


  其中 AFURLSessionManager 是 AFHTTPSessionManager 的父类
  AFURLSessionManager 负责生成 NSURLSession 的实例，管理 AFSecurityPolicy 和 AFNetworkReachabilityManager，来保证请求的安全和查看网络连接情况，它有一个 AFJSONResponseSerializer 的实例来序列化 HTTP 响应
  AFHTTPSessionManager 有着自己的 AFHTTPRequestSerializer 和 AFJSONResponseSerializer 来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能


初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 - GET:parameters:process:success:failure: 的调用栈，看一下 HTTP 请求是如何发出的：

- [AFHTTPSessionManager GET:parameters:process:success:failure:]
	- [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // 返回 NSURLSessionDataTask #1
		- [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] // 返回 NSMutableURLRequest
		- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] // 返回 NSURLSessionDataTask #2
			- [NSURLSession dataTaskWithRequest:] // 返回 NSURLSessionDataTask #3
			- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]
				- [AFURLSessionManagerTaskDelegate init]
				- [AFURLSessionManager setDelegate:forTask:]
	- [NSURLSessionDataTask resume]


在这里 #1 #2 #3 处返回的是同一个 data task，我们可以看到，在 #3 处调用的方法 - [NSURLSession dataTaskWithRequest:] 和只使用 NSURLSession 发出 HTTP 请求时调用的方法 - [NSURLSession dataTaskWithRequest:completionHandler:] 差不多。在这个地方返回 data task 之后，我们再调用 - resume 方法执行请求，并在某些事件执行时通知代理 AFURLSessionManagerTaskDelegate

小结

AFNetworking 实际上只是对 NSURLSession 高度地封装, 提供一些简单易用的 API 方便我们在 iOS 开发中发出网络请求并在其上更快地构建网络层组件并提供合理的接口.

到这里，这一篇文章从上到下对 AFNetworking 是如何调用的进行了一个简单的概述，我会在随后的文章中会具体介绍 AFNetworking 中的每一个模块，了解它们是如何工作，并且如何合理地组织到一起的。

相关文章

关于其他 AFNetworking 源代码分析的其他文章：


  AFNetworking 概述（一）
  AFNetworking 的核心 AFURLSessionManager（二）
  处理请求和响应 AFURLSerialization（三）
  AFNetworkReachabilityManager 监控网络状态（四）
  验证 HTTPS 请求的证书（五）


Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>iOS 源代码分析 -- Masonry</title>
      <url>/ios/2016/11/01/Masonry/</url>
      <content type="text">
  文章来自iOS 源代码分析 — Masonry


Masonry 是 Objective-C 中用于自动布局的第三方框架, 我们一般使用它来代替冗长, 繁琐的 AutoLayout 代码.

Masonry 的使用还是很简洁的:

[button mas_makeConstraints:^(MASConstraintMaker *make) {
	make.centerX.equalTo(self.view);
	make.top.equalTo(self.view).with.offset(40);
	make.width.equalTo(@185);
	make.height.equalTo(@38);
}];


从 mas_makeConstraints: 开始

其中最常用的方法就是

// View+MASAdditions.h

- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;


同样, 也有用于更新和重新构建约束的分类方法:

// View+MASAdditions.h

- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;
- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;


Constraint Maker Block

我们以 mas_makeConstraints: 方法为入口来分析一下 Masonry 以及类似的框架(SnapKit)是如何工作的. mas_makeConstraints: 方法位于 UIView 的分类 MASAdditions 中.


  Provides constraint maker block and convience methods for creating MASViewAttribute which are view + NSLayoutAttribute pairs.

  


这个分类为我们提供一种非常便捷的方法来配置 MASConstraintMaker, 并为视图添加 mas_left mas_right 等属性.

方法的实现如下:

// View+MASAdditions.m

- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {
    self.translatesAutoresizingMaskIntoConstraints = NO;
    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];
    block(constraintMaker);
    return [constraintMaker install];
}


因为 Masonry 是封装的苹果的 AutoLayout 框架, 所以我们要在为视图添加约束前将 translatesAutoresizingMaskIntoConstraints 属性设置为 NO. 如果这个属性没有被正确设置, 那么视图的约束不会被成功添加.

在设置 translatesAutoresizingMaskIntoConstraints 属性之后,


  我们会初始化一个 MASConstraintMaker 的实例.
  然后将 maker 传入 block 配置其属性.
  最后调用 maker 的 install 方法为视图添加约束.


MASConstraintMaker

MASConstraintMaker 为我们提供了工厂方法来创建 MASConstraint. 所有的约束都会被收集直到它们最后调用 install 方法添加到视图上.


  Provides factory methods for creating MASConstraints. Constraints are collected until they are ready to be installed


在初始化 MASConstraintMaker 的实例时, 它会持有一个对应 view 的弱引用, 并初始化一个  constraints 的空可变数组用来之后配置属性时持有所有的约束.

// MASConstraintMaker.m

- (id)initWithView:(MAS_VIEW *)view {
    self = [super init];
    if (!self) return nil;
    
    self.view = view;
    self.constraints = NSMutableArray.new;
    
    return self;
}


这里的 MAS_VIEW 是一个宏, 是 UIView 的 alias.

// MASUtilities.h

#define MAS_VIEW UIView



Setup MASConstraintMaker

在调用 block(constraintMaker) 时, 实际上是对 constraintMaker 的配置.

make.centerX.equalTo(self.view);
make.top.equalTo(self.view).with.offset(40);
make.width.equalTo(@185);
make.height.equalTo(@38);


make.left

访问 make 的 left right top bottom  等属性时, 会调用 constraint:addConstraintWithLayoutAttribute: 方法.

// MASViewConstraint.m

- (MASConstraint *)left {
    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];
}

- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];
}

- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];
    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];
    if ([constraint isKindOfClass:MASViewConstraint.class]) { ... }
    if (!constraint) {
        newConstraint.delegate = self;
        [self.constraints addObject:newConstraint];
    }
    return newConstraint;
}


在调用链上最终会达到 constraint:addConstraintWithLayoutAttribute: 这一方法, 在这里省略了一些暂时不需要了解的问题. 因为在这个类中传入该方法的第一个参数一直为 nil, 所以这里省略的代码不会执行.

这部分代码会先以布局属性 left 和视图本身初始化一个 MASViewAttribute 的实例, 之后使用 MASViewAttribute 的实例初始化一个 constraint 并设置它的代理, 加入数组, 然后返回.

这些工作就是你在输入 make.left 进行的全部工作, 它会返回一个 MASConstraint, 用于之后的继续配置.

make.left.equalTo(@80)

在 make.left 返回 MASConstraint 之后, 我们会继续在这个链式的语法中调用下一个方法来指定约束的关系.

// MASConstraint.h

- (MASConstraint * (^)(id attr))equalTo;
- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;
- (MASConstraint * (^)(id attr))lessThanOrEqualTo;


这三个方法是在 MASViewConstraint 的父类, MASConstraint 中定义的.

MASConstraint 是一个抽象类, 其中有很多的方法都必须在子类中覆写的. Masonry 中有两个 MASConstraint 的子类, 分别是 MASViewConstraint 和 MASCompositeConstraint. 后者实际上是一些约束的集合. 这么设计的原因我们会在 post 的最后解释.

先来看一下这三个方法是怎么实现的:

// MASConstraint.m

- (MASConstraint * (^)(id))equalTo {
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);
    };
}


该方法会导致 self.equalToWithRelation 的执行, 而这个方法是定义在子类中的, 因为父类作为抽象类没有提供这个方法的具体实现.

// MASConstraint.m

- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { MASMethodNotImplemented(); }


MASMethodNotImplemented 也是一个宏定义, 用于在子类未继承这个方法或者直接使用这个类时抛出异常.

// MASConstraint.m

#define MASMethodNotImplemented() \
    @throw [NSException exceptionWithName:NSInternalInconsistencyException \
                                   reason:[NSString stringWithFormat:@&quot;You must override %@ in a subclass.&quot;, NSStringFromSelector(_cmd)] \
                                 userInfo:nil]




因为我们为 equalTo 提供了参数 attribute 和布局关系 NSLayoutRelationEqual, 这两个参数会传递到 equalToWithRelation 中, 设置 constraint 的布局关系和 secondViewAttribute 属性, 为即将 maker 的 install 做准备.

// MASViewConstraint.m

- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {
    return ^id(id attribute, NSLayoutRelation relation) {
        if ([attribute isKindOfClass:NSArray.class]) { ... } 
        else {
            ...
            self.layoutRelation = relation;
            self.secondViewAttribute = attribute;
            return self;
        }
    };
}


我们不得不提一下 setSecondViewAttribute: 方法, 它并不只是一个简单的 setter 方法, 它会根据你传入的值的种类赋值.

// MASConstraintMaker.m

- (void)setSecondViewAttribute:(id)secondViewAttribute {
    if ([secondViewAttribute isKindOfClass:NSValue.class]) {
        [self setLayoutConstantWithValue:secondViewAttribute];
    } else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) {
        _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];
    } else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) {
        _secondViewAttribute = secondViewAttribute;
    } else {
        NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);
    }
}


第一种情况对应的就是:

make.left.equalTo(@40);


传入 NSValue 的时, 会直接设置 constraint 的 offset, centerOffset, sizeOffset, 或者 insets

第二种情况一般会直接传入一个视图:

make.left.equalTo(view);


这时, 就会初始化一个 layoutAttribute 属性与 firstViewArribute 相同的 MASViewAttribute, 上面的代码就会使视图与 view 左对齐.

第三种情况会传入一个视图的 MASViewAttribute:

make.left.equalTo(view.mas_right);


使用这种写法时, 一般是因为约束的方向不同. 这行代码会使视图的左侧与 view 的右侧对齐.

到这里我们就基本完成了对一个约束的配置, 接下来可以使用相同的语法完成对一个视图上所有约束进行配置, 然后进入了最后一个环节.

Install MASConstraintMaker

我们会在 mas_makeConstraints: 方法的最后调用 [constraintMaker install] 方法来安装所有存储在 self.constraints 数组中的所有约束.

// MASConstraintMaker.m

- (NSArray *)install {
    if (self.removeExisting) {
        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];
        for (MASConstraint *constraint in installedConstraints) {
            [constraint uninstall];
        }
    }
    NSArray *constraints = self.constraints.copy;
    for (MASConstraint *constraint in constraints) {
        constraint.updateExisting = self.updateExisting;
        [constraint install];
    }
    [self.constraints removeAllObjects];
    return constraints;
}


在这个方法会先判断当前的视图的约束是否应该要被 uninstall, 如果我们在最开始调用 mas_remakeConstraints: 方法时, 视图中原来的约束就会全部被 uninstall.

然后就会遍历 constraints 数组, 发送 install 消息.

MASViewConstraint install

MASViewConstraint 的 install 方法就是最后为当前视图添加约束的最后的方法, 首先这个方法会先获取即将用于初始化 NSLayoutConstraint 的子类的几个属性.

// MASViewConstraint.m

MAS_VIEW *firstLayoutItem = self.firstViewAttribute.view;
NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;
MAS_VIEW *secondLayoutItem = self.secondViewAttribute.view;
NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;


Masonry 之后会判断当前即将添加的约束是否是 size 类型的约束

// MASViewConstraint.m

if (!self.firstViewAttribute.isSizeAttribute &amp;amp;&amp;amp; !self.secondViewAttribute) {
   secondLayoutItem = firstLayoutItem.superview;
   secondLayoutAttribute = firstLayoutAttribute;
}


如果不是 size 类型并且没有提供第二个 viewAttribute, (e.g. make.left.equalTo(@10);) 会自动将约束添加到 superview 上. 它等价于:

make.left.equalTo(superView.mas_left).with.offset(10);


然后就会初始化 NSLayoutConstraint 的子类 MASLayoutConstraint:

// MASViewConstraint.m

MASLayoutConstraint *layoutConstraint
   = [MASLayoutConstraint constraintWithItem:firstLayoutItem
                                   attribute:firstLayoutAttribute
                                   relatedBy:self.layoutRelation
                                      toItem:secondLayoutItem
                                   attribute:secondLayoutAttribute
                                  multiplier:self.layoutMultiplier
                                    constant:self.layoutConstant];
layoutConstraint.priority = self.layoutPriority;                                    


接下来它会寻找 firstLayoutItem 和 secondLayoutItem 两个视图的公共 superview, 相当于求两个数的最小公倍数.

// View+MASAdditions.m

- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {
    MAS_VIEW *closestCommonSuperview = nil;

    MAS_VIEW *secondViewSuperview = view;
    while (!closestCommonSuperview &amp;amp;&amp;amp; secondViewSuperview) {
        MAS_VIEW *firstViewSuperview = self;
        while (!closestCommonSuperview &amp;amp;&amp;amp; firstViewSuperview) {
            if (secondViewSuperview == firstViewSuperview) {
                closestCommonSuperview = secondViewSuperview;
            }
            firstViewSuperview = firstViewSuperview.superview;
        }
        secondViewSuperview = secondViewSuperview.superview;
    }
    return closestCommonSuperview;
}


如果需要升级当前的约束就会获取原有的约束, 并替换为新的约束, 这样就不需要再次为 view 安装约束.

// MASViewConstraint.m

MASLayoutConstraint *existingConstraint = nil;
if (self.updateExisting) {
   existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];
}
if (existingConstraint) {
   // just update the constant
   existingConstraint.constant = layoutConstraint.constant;
   self.layoutConstraint = existingConstraint;
} else {
   [self.installedView addConstraint:layoutConstraint];
   self.layoutConstraint = layoutConstraint;
}
    
[firstLayoutItem.mas_installedConstraints addObject:self];


如果原来的 view 中不存在可以升级的约束, 或者没有调用 mas_updateConstraint: 方法, 那么就会在上一步寻找到的 installedView 上面添加约束.

[self.installedView addConstraint:layoutConstraint];


其他问题

到现在为止整个 Masonry 为视图添加约束的过程就已经完成了, 然而我们还有一些待解决的其它问题.

make.left.equal(view).with.offset(30)

我们在前面的讨论中已经讨论了这个链式语法的前半部分, 但是在使用中也会”延长”这个链式语句, 比如添加 with offset.

其实在 Masonry 中使用 with 并不是必须的, 它的作用仅仅是使代码更加的易读.


  Optional semantic property which has no effect but improves the readability of constraint


// MASConstraint.m
- (MASConstraint *)with {
    return self;
}

- (MASConstraint *)and {
    return self;
}


与 with 有着相同作用的还有 and, 这两个方法都会直接返回 MASConstraint, 方法本身不做任何的修改.

而 offset 方法其实是修改 layoutConstraint 中的常量, 因为 self.layoutConstant 在初始化时会被设置为 0, 我们可以通过修改 offset 属性来改变它.

// MASViewConstraint.m

- (void)setOffset:(CGFloat)offset {
    self.layoutConstant = offset;
}


MASCompositeConstraint

MASCompositeConstraint 是一些 MASConstraint 的集合, 它能够提供一种更加便捷的方法同时为一个视图来添加多个约束.


  A group of MASConstraint objects


通过 make 直接调用 edges size center 时, 就会产生一个 MASCompositeConstraint 的实例, 而这个实例会初始化所有对应的单独的约束.

// MASConstraintMaker.m

- (MASConstraint *)edges {
    return [self addConstraintWithAttributes:MASAttributeTop | MASAttributeLeft | MASAttributeRight | MASAttributeBottom];
}

- (MASConstraint *)size {
    return [self addConstraintWithAttributes:MASAttributeWidth | MASAttributeHeight];
}

- (MASConstraint *)center {
    return [self addConstraintWithAttributes:MASAttributeCenterX | MASAttributeCenterY];
}


这些属性都会调用 addConstraintWithAttributes: 方法, 生成多个属于 MASCompositeConstraint 的实例.

// MASConstraintMaker.m

NSMutableArray *children = [NSMutableArray arrayWithCapacity:attributes.count];
    
for (MASViewAttribute *a in attributes) {
   [children addObject:[[MASViewConstraint alloc] initWithFirstViewAttribute:a]];
}
    
MASCompositeConstraint *constraint = [[MASCompositeConstraint alloc] initWithChildren:children];
constraint.delegate = self;
[self.constraints addObject:constraint];
return constraint;


mas_equalTo

Masonry 中还有一个类似与 magic 的宏, 这个宏将 C 和 Objective-C 语言中的一些基本数据结构比如说 double CGPoint CGSize 这些值用 NSValue 进行包装.

这是一种非常简洁的使用方式, 如果你对这个非常感兴趣, 可以看一下 MASUtilities.h 中的源代码, 在这里就不对这个做出解释了.

Masonry 如何为视图添加约束(面试回答)

Masonry 与其它的第三方开源框架一样选择了使用分类的方式为 UIKit 添加一个方法 mas_makeConstraint, 这个方法接受了一个 block, 这个 block 有一个 MASConstraintMaker 类型的参数, 这个 maker 会持有一个约束的数组, 这里保存着所有将被加入到视图中的约束.

我们通过链式的语法配置 maker, 设置它的 left right 等属性, 比如说 make.left.equalTo(view), 其实这个 left equalTo 还有像 with offset 之类的方法都会返回一个 MASConstraint 的实例, 所以在这里才可以用类似 Ruby 中链式的语法.

在配置结束后, 首先会调用 maker 的 install 方法, 而这个 maker 的 install 方法会遍历其持有的约束数组, 对其中的每一个约束发送 install 消息. 在这里就会使用到在上一步中配置的属性, 初始化 NSLayoutConstraint 的子类 MASLayoutConstraint 并添加到合适的视图上.

视图的选择会通过调用一个方法 mas_closestCommonSuperview: 来返回两个视图的最近公共父视图.

总结

虽然 Masonry 这个框架中的代码并不是非常的多, 只有 1,2 万行的代码, 但是感觉这个项目阅读起来十分的困难, 没有 SDWebImage 清晰, 因为代码中类的属性非常的多, 而且有很多相似的属性会干扰我们对这个项目的阅读, 整个框架运用了大量的 block 语法进行回调.

虽然代码十分整洁不过我觉得却降低了可读性, 但是还是那句话, 把简洁留给别人复杂留给自己, 只要为开发者提供简洁的接口就可以了.

Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>iOS 源代码分析 -- SDWebImage</title>
      <url>/ios/2016/10/18/SDWebImage/</url>
      <content type="text">
  文章来自iOS 源代码分析 — SDWebImage


世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 在暑假的时候我曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘.

而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码, 也准备开始写一些关于 iOS 源代码分析的 post.

第一篇文章为什么选择 SDWebImage, 原因其实我也忘了…. :(

简洁的接口

首先来介绍一下这个 SDWebImage 这个著名开源框架吧, 这个开源框架的主要作用就是:


  Asynchronous image downloader with cache support with an UIImageView category.


一个异步下载图片并且支持缓存的 UIImageView 分类.

就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:

[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;url&quot;]
                  placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];


当然这个框架中还有 UIButton 的分类, 可以给 UIButton 异步加载图片, 不过这个并没有 UIImageView 分类中的这个方法常用.

这个框架的设计还是极其的优雅和简洁, 主要的功能就是这么一行代码, 而其中复杂的实现细节全部隐藏在这行代码之后, 正应了那句话:


  把简洁留给别人, 把复杂留给自己.


我们已经看到了这个框架简洁的接口, 接下来我们看一下 SDWebImage 是用什么样的方式优雅地实现异步加载图片和缓存的功能呢?

复杂的实现

其实复杂只是相对于简洁而言的, 并不是说 SDWebImage 的实现就很糟糕, 相反, 它的实现还是非常 amazing 的, 在这里我们会忽略很多的实现细节, 并不会对每一行源代码逐一解读.

首先, 我们从一个很高的层次来看一下这个框架是如何组织的.



这张图片已经将这个框架是如何组织的基本展示了出来, UIImageView+WebCache 和 UIButton+WebCache 直接为表层的 UIKit 框架提供接口, 而 SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.

UIImageView+WebCache

接下来我们就以 UIImageView+WebCache 中的

- (void)sd_setImageWithURL:(NSURL *)url 
          placeholderImage:(UIImage *)placeholder;


这一方法为入口研究一下 SDWebImage 是怎样工作的. 我们打开上面这段方法的实现代码 UIImageView+WebCache.m

当然你也可以 git clone git@github.com:rs/SDWebImage.git 到本地来查看.

- (void)sd_setImageWithURL:(NSURL *)url 
          placeholderImage:(UIImage *)placeholder {
    [self sd_setImageWithURL:url 
            placeholderImage:placeholder 
                     options:0 
                    progress:nil 
                   completed:nil];
}


这段方法唯一的作用就是调用了另一个方法

[self sd_setImageWithURL:placeholderImage:options:progress:completed:]


在这个文件中, 你会看到很多的 sd_setImageWithURL...... 方法, 它们最终都会调用上面这个方法, 只是根据需要传入不同的参数, 这在很多的开源项目中乃至我们平时写的项目中都是很常见的. 而这个方法也是 UIImageView+WebCache 中的核心方法.

这里就不再复制出这个方法的全部实现了.

操作的管理

这是这个方法的第一行代码:

// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #1

[self sd_cancelCurrentImageLoad];


这行看似简单的代码最开始是被我忽略的, 我后来才发现蕴藏在这行代码之后的思想, 也就是 SDWebImage 管理操作的办法.

框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个  operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.

这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用:

// UIImageView+WebCache
// sd_cancelCurrentImageLoad #1

[self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;]


而这个方法会使当前 UIImageView 中的所有操作都被 cancel. 不会影响之后进行的下载操作.



占位图的实现

// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #4

if (!(options &amp;amp; SDWebImageDelayPlaceholder)) {
    self.image = placeholder;
}


如果传入的 options 中没有 SDWebImageDelayPlaceholder(默认情况下 options == 0), 那么就会为 UIImageView 添加一个临时的 image, 也就是占位图.



获取图片

// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #8

if (url)


接下来会检测传入的 url 是否非空, 如果非空那么一个全局的 SDWebImageManager 就会调用以下的方法获取图片:

[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]


下载完成后会调用 (SDWebImageCompletionWithFinishedBlock)completedBlock 为 UIImageView.image 赋值, 添加上最终所需要的图片.

// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #10

dispatch_main_sync_safe(^{
    if (!wself) return;
    if (image) {
        wself.image = image;
        [wself setNeedsLayout];
    } else {
        if ((options &amp;amp; SDWebImageDelayPlaceholder)) {
            wself.image = placeholder;
            [wself setNeedsLayout];
        }
    }
    if (completedBlock &amp;amp;&amp;amp; finished) {
        completedBlock(image, error, cacheType, url);
    }
});




dispatch_main_sync_safe 宏定义

上述代码中的 dispatch_main_sync_safe 是一个宏定义, 点进去一看发现宏是这样定义的

#define dispatch_main_sync_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_sync(dispatch_get_main_queue(), block);\
    }


相信这个宏的名字已经讲他的作用解释的很清楚了: 因为图像的绘制只能在主线程完成, 所以, dispatch_main_sync_safe 就是为了保证 block 能在主线程中执行.



而最后, 在 [SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:] 返回 operation 的同时, 也会向 operationDictionary 中添加一个键值对, 来表示操作的正在进行:

// UIImageView+WebCache
// sd_setImageWithURL:placeholderImage:options:progress:completed: #28

[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];


它将 opertion 存储到 operationDictionary 中方便以后的 cancel.

到此为止我们已经对 SDWebImage 框架中的这一方法分析完了, 接下来我们将要分析 SDWebImageManager 中的方法

[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]


SDWebImageManager

在 SDWebImageManager.h 中你可以看到关于 SDWebImageManager 的描述:


  The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.


这个类就是隐藏在 UIImageView+WebCache 背后, 用于处理异步下载和图片缓存的类, 当然你也可以直接使用 SDWebImageManager 的上述方法 downloadImageWithURL:options:progress:completed: 来直接下载图片.

可以看到, 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader, SDImageCache 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.

// SDWebImageManager
// downloadImageWithURL:options:progress:completed: #6

if ([url isKindOfClass:NSString.class]) {
    url = [NSURL URLWithString:(NSString *)url];
}

if (![url isKindOfClass:NSURL.class]) {
    url = nil;
}


这块代码的功能是确定 url 是否被正确传入, 如果传入参数的是 NSString 类型就会被转换为 NSURL. 如果转换失败, 那么 url 会被赋值为空, 这个下载的操作就会出错.



SDWebImageCombinedOperation

当 url 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 SDWebImageOperation 协议的 NSObject 的子类. 而这个协议也非常的简单:

@protocol SDWebImageOperation &amp;lt;NSObject&amp;gt;

- (void)cancel;

@end


这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法. (不知道这句看似像绕口令的话, 你看懂没有, 如果没看懂..请多读几遍).

而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的两个 operation 都被 cancel.

// SDWebImageCombinedOperation
// cancel #1

- (void)cancel {
    self.cancelled = YES;
    if (self.cacheOperation) {
        [self.cacheOperation cancel];
        self.cacheOperation = nil;
    }
    if (self.cancelBlock) {
        self.cancelBlock();
        _cancelBlock = nil;
    }
}


而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的.



既然我们获取了 url, 再通过 url 获取对应的 key

NSString *key = [self cacheKeyForURL:url];


下一步是使用 key 在缓存中查找以前是否下载过相同的图片.

operation.cacheOperation = [self.imageCache 
		queryDiskCacheForKey:key 
        			    done:^(UIImage *image, SDImageCacheType cacheType) { ... }];


这里调用 SDImageCache 的实例方法 queryDiskCacheForKey:done: 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 NSOperation.

如果我们在缓存中查找到了对应的图片, 那么我们直接调用 completedBlock 回调块结束这一次的图片下载操作.

// SDWebImageManager
// downloadImageWithURL:options:progress:completed: #47

dispatch_main_sync_safe(^{
    completedBlock(image, nil, cacheType, YES, url);
});


如果我们没有找到图片, 那么就会调用 SDWebImageDownloader 的实例方法:

id &amp;lt;SDWebImageOperation&amp;gt; subOperation =
  [self.imageDownloader downloadImageWithURL:url 
                                     options:downloaderOptions 
                                    progress:progressBlock 
                                   completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) { ... }];


如果这个方法返回了正确的 downloadedImage, 那么我们就会在全局的缓存中存储这个图片的数据:

[self.imageCache storeImage:downloadedImage 
	   recalculateFromImage:NO 
                  imageData:data 
                     forKey:key 
                     toDisk:cacheOnDisk];


并调用 completedBlock 对 UIImageView 或者 UIButton 添加图片, 或者进行其它的操作.

最后, 我们将这个 subOperation 的 cancel 操作添加到 operation.cancelBlock 中. 方便操作的取消.

operation.cancelBlock = ^{
    [subOperation cancel];
    }


SDWebImageCache

SDWebImageCache.h 这个类在源代码中有这样的注释:


  SDImageCache maintains a memory cache and an optional disk cache.


它维护了一个内存缓存和一个可选的磁盘缓存, 我们先来看一下在上一阶段中没有解读的两个方法, 首先是:

- (NSOperation *)queryDiskCacheForKey:(NSString *)key 
                                 done:(SDWebImageQueryCompletedBlock)doneBlock;


这个方法的主要功能是异步的查询图片缓存. 因为图片的缓存可能在两个地方, 而该方法首先会在内存中查找是否有图片的缓存.

// SDWebImageCache
// queryDiskCacheForKey:done: #9

UIImage *image = [self imageFromMemoryCacheForKey:key];


这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.

如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..

在这里会调用一个方法 diskImageForKey 这个方法的具体实现我在这里就不介绍了, 涉及到很多底层 Core Foundation 框架的知识, 不过这里文件名字的存储使用 MD5 处理过后的文件名.

// SDImageCache
// cachedFileNameForKey: #6

CC_MD5(str, (CC_LONG)strlen(str), r);


对于其它的实现细节也就不多说了…

如果在磁盘中查找到对应的图片, 我们会将它复制到内存中, 以便下次的使用.

// SDImageCache
// queryDiskCacheForKey:done: #24

UIImage *diskImage = [self diskImageForKey:key];
if (diskImage) {
    CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale;
    [self.memCache setObject:diskImage forKey:key cost:cost];
}


这些就是 SDImageCache 的核心内容了, 而接下来将介绍如果缓存没有命中, 图片是如何被下载的.

SDWebImageDownloader

按照之前的惯例, 我们先来看一下 SDWebImageDownloader.h 中对这个类的描述.


  Asynchronous downloader dedicated and optimized for image loading.


专用的并且优化的图片异步下载器.

这个类的核心功能就是下载图片, 而核心方法就是上面提到的:

- (id &amp;lt;SDWebImageOperation&amp;gt;)downloadImageWithURL:(NSURL *)url 
        options:(SDWebImageDownloaderOptions)options 
       progress:(SDWebImageDownloaderProgressBlock)progressBlock 
      completed:(SDWebImageDownloaderCompletedBlock)completedBlock;


回调

这个方法直接调用了另一个关键的方法:

- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock 
          andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock 
                     forURL:(NSURL *)url 
             createCallback:(SDWebImageNoParamsBlock)createCallback


它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:

// SDWebImageDownloader
// addProgressCallback:andCompletedBlock:forURL:createCallback: #10

BOOL first = NO;
if (!self.URLCallbacks[url]) {
    self.URLCallbacks[url] = [NSMutableArray new];
    first = YES;
}

// Handle single download of simultaneous download request for the same URL
NSMutableArray *callbacksForURL = self.URLCallbacks[url];
NSMutableDictionary *callbacks = [NSMutableDictionary new];
if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
[callbacksForURL addObject:callbacks];
self.URLCallbacks[url] = callbacksForURL;

if (first) {
    createCallback();
}


方法会先查看这个 url 是否有对应的 callback, 使用的是 downloader 持有的一个字典 URLCallbacks.

如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.

然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.

NSMutableArray *callbacksForURL = self.URLCallbacks[url];
NSMutableDictionary *callbacks = [NSMutableDictionary new];
if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
[callbacksForURL addObject:callbacks];
self.URLCallbacks[url] = callbacksForURL;




如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.

// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #4

[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{ ... }];


我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 NSMutableURLRequest:

// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #11

NSMutableURLRequest *request = [[NSMutableURLRequest alloc] 
		initWithURL:url 
        cachePolicy:...
    timeoutInterval:timeoutInterval];


这个 request 就用于在之后发送 HTTP 请求.

在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类,

// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #20

operation = [[SDWebImageDownloaderOperation alloc] 
		initWithRequest:request
                options:options
               progress:...
              completed:...
              cancelled:...}];


但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.

// SDWebImageDownloader
// downloadImageWithURL:options:progress:completed: #59

[wself.downloadQueue addOperation:operation];


只有将它加入到这个下载队列中, 这个操作才会执行.

SDWebImageDownloaderOperation

这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.

// SDWebImageDownloaderOperation
// start #1

@synchronized (self) {
    if (self.isCancelled) {
        self.finished = YES;
        [self reset];
        return;
    }
    self.executing = YES;
    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
    self.thread = [NSThread currentThread];
}


而接下来这个 connection 就会开始运行:

// SDWebImageDownloaderOperation
// start #29

[self.connection start];


它会发出一个 SDWebImageDownloadStartNotification 通知

// SDWebImageDownloaderOperation
// start #35

[[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];


代理

在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;


在这三个代理方法中的前两个会不停回调 progressBlock 来提示下载的进度.

而最后一个代理方法会在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.

而这里调用的 progressBlock completionBlock cancelBlock 都是在之前存储在 URLCallbacks 字典中的.



到目前为止, 我们就基本解析了 SDWebImage 中

[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;url&quot;]
                  placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];


这个方法执行的全部过程了.

流程图

我们使用一个流程图来表示上述方法所执行的全过程.



这段流程图展示了上述方法调用中大部分重要方法的调用.

SDWebImage 如何为 UIImageView 添加图片(面试回答)

SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, sd_setImageWithURL:placeholderImage:, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage.

然后会获取 SDWebImageManager 中的单例调用一个 downloadImageWithURL:... 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.

然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 SDWebImageDownloader 对象的方法 downloadImageWithURL:... 来下载图片, 这个方法会在执行的过程中调用另一个方法 addProgressCallback:andCompletedBlock:forURL:createCallback: 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.

而在图片下载完成之后, 就会在主线程设置 image 属性, 完成整个图像的异步下载和配置.

总结

SDWebImage 的图片加载过程其实很符合我们的直觉:


  查看缓存
    
      缓存命中
  	* 返回图片
        
          更新 UIImageView
        
      
      缓存未命中
  	* 异步下载图片
        
          加入缓存
          更新 UIImageView
        
      
    
  


只要有足够的耐心, 阅读这个开源项目的源代码也是没有太多困难的.

SDWebImage 的探索到目前为止差不多结束了, 对于这个框架的学习以及解析确实使我受益匪浅, 我也将在之后继续阅读其它的著名框架的源代码. 在这篇博客之中难免会有错误, 希望各位能够指正~

Follow: @Draveness

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>如何进行科学上网</title>
      <url>/ios/2016/06/28/%E4%BF%AE%E6%94%B9-host-%E8%BF%9B%E8%A1%8C%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      <content type="text">如何进行科学上网


  修改Host的作用？


为了方便用户记忆，我们将IP变成一个个的域名来输入到浏览器进行访问。而这使得访问网站时要先将其域名解析成 IP 。DNS (Domain Name Server) 的作用就是进行 IP 解析，把域名对应到 IP。想了解更多关于DNS，可以查看 浅谈DNS原理 这篇文章。

在 Great FireWall 的 5 种封锁方法中，有一种简单而效果很好的方法是 DNS 污染。GFW 会对 DNS 的解析过程进行干扰，这会使对某些被干扰的域名返回一个错误的 IP 地址给你的主机，使你无法正确连接到你要的服务器上读取正确的信息。

Hosts 文件本来是用来提高解析效率。在进行 DNS 请求以前，系统会先检查自己的 Hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。所以，当我们直接将 Google、Twitter、Facebook 之类的 IP 放入 Hosts 文件后，就可以跳过 DNS 的解析这一步，直接就行 IP 访问，不受 GFW 的 DNS 污染干扰了。

下载最新可用 host 文件
点击下载 密码: mp3a

host 文件位置

win用户 打开“c:\windows\system32\drivers\etc”目录，对于win7系统来说，请用管理员身份打开hosts。

Android用户：首先必须root手机，然后安装root explorer管理器，打开进入/system/etc目录,长按host文件，弹出菜单拉到下面会看到“文本编辑器方式打开”。编辑输入即可。

Mac OS用户： host位置为：/private/etc/hosts

iPhone用户：需越狱，使用 iFunBox、PP助手等访问设备文件系统，备份并修改该文件后覆盖：/etc/hosts

上面hosts保存成功后一般立刻就可以打开google，如果还不能打开，可以尝试点击此地址 google

2017-11-29更新

现在封锁都升级了，不是针对 IP 地址的了，而是针对每一个网络连接。受限于为数不多的几个出入境节点，所有网民的每一个出境网络连接实际上都被扫描过一遍。于是网络协议最初设计时，并未考虑封锁这回事，无论是 HTTP 还是 HTTPS，只需要扫描每个连接的前几十个字节，就可以得到其目标地址（域名）。HTTP 是通过其 Host 头，而 HTTPS 是通过 SNI。

至此，针对域名，没有封不掉的，只有不想封的。在直线连接几乎不可能的之后，那就只能绕路了，也就是代理。

现在比较的靠谱的是 Shadowsocks和 V2Ray，具体有需求的可以去了解下。

Shadowsocks 本质上是 Socks 的加密版本，可选择多种加密方式。一旦加了密，其传输的数据就无法被第三方检测了。并且 Shadowsocks 在转发数据之前，可以对其目的地进行判断，比如可以只转发去往 Google 的流量，而优酷的流量依然直连。在经常一段时间的优化之后，Shadowsocks 可以达到一个全局较快的连接速度。

</content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
          <tag> iOS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
